<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
                          _   _
     _  _    _     _  _  | | | |   __     ____
    | |/ \  | |_  | |/_| | | | |  /  \   /    \
    | |   | |  _| |  /   | | | | | || | |  ||  |
    | |   | | |_  | |    | | | | | || | |  ||  |
    |_|   | |___| |_|    |_| |_|  \__/   \____/|
                                               |
                                          ____/
    -->
    <title>ntrllog | Functional Programming</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../pictures/favicon.ico"/>
    <link href="../css/content.css" rel="stylesheet">
  </head>
  <body>
    <div class="dropdown ln-fixed-right">
      <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">ToC</button>
      <ul class="dropdown-menu">
        <li><a class="dropdown-item" href="#purefuncs">Pure Functions</a></li>
        <li><a class="dropdown-item" href="#dataimmutability">Data Immutability</a></li>
        <li><a class="dropdown-item" href="#whyfp">Why Functional Programming?</a></li>
        <li><a class="dropdown-item" href="#tailrecursion">Tail Recursion</a></li>
        <li><a class="dropdown-item" href="#currying">Currying</a></li>
        <li><a class="dropdown-item" href="#polymorphic">Polymorphic Functions</a></li>
      </ul>
    </div>
    <div class="container ln-line-height">
      <a href="projects.html"><i class="fas fa-long-arrow-alt-left fa-2x"></i></a>
      <h1>Functional Programming</h1>
      <hr>
      <p>Shortcut to this page: <a href="fp.html">ntrllog.netlify.app/fp</a></p>
      <p>Notes provided by Professor John Hurley</p>
      <p>(all code examples are done in Kotlin with expression bodies when possible)</p>
      <h2 id="purefuncs">Pure Functions</h2>
      <p>A pure function is a function that:</p>
      <ul>
        <li>always returns the same value for the same input</li>
        <li>has no side effects</li>
      </ul>
      <h3>Referential Transparency</h3>
      <p>Consider the function:</p>
      <div class="ln-center">
        <p><code>fun doubleIt(n: Int): Int = n * 2</code></p>
      </div>
      <p>and consider the input `n=3`. We can see that for `n=3`, the output will always be `6` no matter what.</p>
      <p>This can be thought of as referential transparency, meaning that calls to the same function with the same arguments will always return the same value.</p>
      <div class="ln-box">
        <p>Technically, referential transparency refers to the ability to replace an expression with its value while still maintaining the correctness of the code. For example, if, for some reason, we had <code>doubleIt(3)</code> in our code, we could replace it with <code>6</code> and the program would still work the same way.</p>
        <div class="ln-center">
          <p><code>val x = doubleIt(3) // this line can be rewritten as val x = 6</code></p>
        </div>
        <p>This replacement is possible only because the function will always return the same value for the same input. Which is why the definition of referential transparency can be thought of this way.</p>
        <p>(In a way, the definition of referential transparency is referentially transparent? ü§îüòè)</p>
      </div>
      <h4>That's Not Very Referentially Transparent of You</h4>
      <p>An example of a function that's not referentially transparent is this:</p>
      <div class="ln-flex-center">
        <p><code>val cost = 0.73<br>fun getCost(n: Int): Double = n * cost</code></p>
      </div>
      <p>If the value of <code>cost</code> is changed, then <code>getCost()</code> will return something different for the same input.</p>
      <h3>Side Effects</h3>
      <p>Side effects are changes that are caused by a function call, but the changes themselves occur outside of the function call. These changes usually are not necessary for calculating the return value of the function (assuming, in the spirit of functional programming, that the primary purpose of a function is to return something rather than do something). Some examples of side effects are:</p>
      <ul>
        <li>modifying a variable beyond the scope of the block where the change occurs</li>
        <li>modifying a data structure in place</li>
        <li>setting a field on an object</li>
        <li>throwing an exception or halting with an error</li>
        <li>printing to the console</li>
        <li>reading user input</li>
        <li>reading from or writing to a file</li>
        <li>drawing on the screen</li>
      </ul>
      <p>This is an example of a function that modifies a variable outside of its scope (and prints):</p>
      <div class="ln-flex-center">
        <p><code>var counter = 0<br>fun incrementCounter() {<br>&nbsp;&nbsp;&nbsp;&nbsp;++counter<br>&nbsp;&nbsp;&nbsp;&nbsp;println(counter)<br>}</code></p>
      </div>
      <h2 id="dataimmutability">Data Immutability</h2>
      <p>In functional programming, data are not allowed to be changed* once it is created. So something as simple (and seemingly essential) as a loop is not allowed. Consider this loop:</p>
      <div class="ln-flex-center">
        <p><code>for (num in numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;squaredNums += listOf(num * num)<br>}</code></p>
      </div>
      <p><code>num</code> and <code>squaredNums</code> are being changed on every iteration of the loop, and data are not allowed to be changed!</p>
      <p>*Changed means reassigned to a different value.</p>
      <p>Instead of loops, recursion is used.</p>
      <p>In the context of lists, if we want a different list (e.g., one of the elements need to be changed or removed), then we need to create a new list instead of modifying the original list.</p>
      <div class="ln-flex-center">
        <p><code>val originalList = listOf(1, 2, 3, 4, 5)<br>val newList = originalList.slice(0..1) + originalList.slice(3..originalList.size-1) // newList = [1, 2, 4, 5]</code></p>
      </div>
      <h2 id="whyfp">Why Functional Programming?</h2>
      <p>With functional programming, there are no side effects; there are no mutable data; and there is referential transparency. All of these make functional programming great for concurrent programming because there is no shared state, data synchronization issues, race conditions, and deadlocks.</p>
      <p>The code is more modular since there is no shared state.</p>
      <p>Pure functions are less buggy than impure functions. Since they don't depend on external state, pure functions are more reliable once they are thoroughly tested. Pure functions also don't have side effects, so they don't create unpredictable problems.</p>
      <p>Referential transparency makes it possible to cache the result of a function call, so that the result can be used instead of calling the function again. (This is called memoization.)<p>
      <h2 id="tailrecursion">Tail Recursion</h2>
      <p>Whenever a function call is made, a stack is created for that function call. So for recursive functions, a stack is created for each recursive call.</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int = if (n &lt;= 1) n else n * factorial(n-1)</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/recursion.gif">
      </div>
      <p>If too many recursive calls are made, then too many stacks will be created, resulting in a stack overflow. Since we're pretty much limited to recursion in functional programming, we have to find a way to use recursion without running into a stack overflow.</p>
      <p>Well, we can avoid having too many stacks by getting rid of them once we don't need them anymore. Going back to the recursion animation above, notice that each stack after the main stack needs to allocate memory for an Int (the <code>n</code> in <code>n * factorial(n-1)</code>). This means that the recursive call is <em>not</em> the last thing that is performed in the stack (the multiplication is the last thing being performed). Because we need to store the <code>n</code> in each stack in order for the recursion to work, we cannot simply remove the stack after a recursive call. But it would be nice to be able to do so!</p>
      <p>So if we don't want to store anything in each stack, then that means we should push all the information we need to the next stack. Consider this modified factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3, 1)<br>}<br>fun factorial(n: Int, accumulator: Int): Int = if (n &lt;= 1) accumulator else factorial(n-1, n * accumulator)</code></p>
      </div>
      <p>This modification pushes the result of each multiplication forward (in the <code>accumulator</code>) so that it doesn't need to be stored.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.png">
        <p>(lol there's no animation here.)</p>
      </div>
      <p>Notice now that the recursive call <em>is</em> the last thing that is performed in the stack and that no memory needs to be allocated to store anything ‚Äî this is tail recursion! Capable compilers are able to take advantage of this and remove the previous stack on each recursive call ‚Äî after all, there's no important information being stored in the previous stack (this is tail-call elimination/optimization!)</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.gif">
      </div>
      <p>The fact that the stacks can be removed is nice, but this factorial function is a bit awkward. It's not intuitive to need two parameters to calculate the factorial of a number. In addition, if we accidentally put the wrong initial value for the accumulator, then the answer will be wrong.</p>
      <h3>Helper Function to the Rescue!</h3>
      <p>Consider this final version of the factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: Int, accumulator: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt;= 1) accumulator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x-1, x * accumulator)<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(n, 1)<br>}</code></p>
      </div>
      <p>Here, we have a nested function (<code>helper()</code>) that is called recursively. The outer function (<code>factorial()</code>) is no longer called recursively; instead it kicks off the recursive process. This allows the factorial function to be clean while still getting the benefits of tail-call elimination.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_2.gif">
      </div>
      <h3>A Systematic Approach to Making Functions Tail Recursive</h3>
      <p>There are three main ideas:</p>
      <ul>
        <li>there is an outer function that defines and calls an inner function, which is going to be the recursive one</li>
        <li>the inner function takes in an accumulator that starts with an initial value and builds up the result at each recursive step</li>
        <li>the base case returns the accumulator</li>
      </ul>
      <p>Let's look at string reversal as an example.</p>
      <p>There is an outer function:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {</code></p>
      </div>
      <p>That defines an inner function, which takes in an accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =</code></p>
      </div>
      <p>The base case returns the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc</code></p>
      </div>
      <p>The inner function is recursive and the accumulator builds up the result at each recursive step:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])</code></p>
      </div>
      <p>The outer function calls the inner function with an initial value for the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s, "")<br>}</code></p>
      </div>
      <div class="ln-box">
        <h2>A Different Way To Recurse</h2>
        <p>Now, I don't know about you, but when I learned about recursion, there was always some argument that would get smaller with each recursive call. For example, in the example above, the string being passed to the recursive helper function is getting smaller by one character each time until it is empty. I never really realized that this is not the only way to do things recursively.</p>
        <p>If working with strings or lists, then instead of making the string or list smaller in each recursive call, we can just pass an increasing (or decreasing) index instead. ü§Ø</p>
        <div class="ln-flex-center">
          <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt; 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(n-1, acc + s[n])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s.length-1, "")<br>}</code></p>
        </div>
      </div>
      <h2 id="currying">Currying</h2>
      <p>Currying is taking a function with multiple arguments and breaking it up into mutiple functions, each with one argument.</p>
      <p>(I feel like a function that adds two numbers is a very contrived and overused example, but let's roll with it!) Suppose we have a function that adds two numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun myAdd(x: Int, y: Int): Int = x + y</code></p>
      </div>
      <p>Now suppose we have a use case where we always want to add `5` to any number. Of course, we can simply just do <code>myAdd(x, 5)</code>, whenever we need to, but we can make the function calls simpler and clearer. The idea is to create a new function (let's call it <code>addFive()</code>) that takes in only one argument and adds `5` to it. Simpler and clearer.</p>
      <p>Time to curry the <code>myAdd()</code> function!</p>
      <div class="ln-flex-center">
        <p><code>fun addCurried(x: Int): (Int) -> Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(y: Int): Int = x + y<br>}<br>val add5 = addCurried(5)<br>val r = add5(10) // r = 15</code></p>
      </div>
      <p>We broke the <code>myAdd()</code> function into two smaller functions, each with one argument. The outer function takes in one of the arguments (<code>x</code>) and simply returns another function. That other function takes in the other argument (<code>y</code>) and does what the original <code>myAdd()</code> function would've done. Since the outer function returns a function, we can create new functions, like <code>add5()</code>.</p>
      <div class="ln-box">
        <h3>Closure</h3>
        <p>When we return from a function, everything in that function's scope gets destroyed. So it's interesting to note here that even when <code>addCurried()</code> returned, <code>add5()</code> still had access to the `5`, which was passed through <code>x</code>. Theoretically, <code>x</code> looks like it should've been inaccessible after <code>addCurried()</code> returned. But it isn't. A closure is a function that can access a variable that is defined outside of its scope, even after the outer function has returned.</p>
      </div>
      <p>Let's look at a more complicated, but more practical, example. Suppose we had our own filter function that filtered a list based on a custom function:</p>
      <div class="ln-flex-center">
        <p><code>fun myFilter(l: List&lt;Int&gt;, f: (Int) -> Boolean): List&lt;Int&gt; = l.filter(f)</code></p>
      </div>
      <p>Time to curry!</p>
      <div class="ln-flex-center">
        <p><code>fun filterCurried(f: (Int) -> Boolean): (List&lt;Int&gt;) -> List&lt;Int&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter(f)<br>}<br>val isEven = { n: Int -> n % 2 == 0 }<br>val filterEven = filterCurried(isEven)<br>println(filterEven(listOf(1, 2, 3, 4, 5, 6)) // prints [2, 4, 6]</code></p>
      </div>
      <p>With this example, we can see a more useful reason to use currying. Imagine if we wanted to create <code>filterEven()</code> and <code>filterOdd()</code> but without currying.</p>
      <div class="ln-flex-center">
        <p><code>fun filterEven(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 0}<br>fun filterOdd(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 1}</code></p>
      </div>
      <p>Notice how they're almost exactly the same. It seems like wasted repetition to create two similarly-defined functions this way.</p>
      <h2 id="polymorphic">Polymorphic Functions</h2>
      <p>Consider this function that searches for a string in a list of strings:</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;String&gt;, key: String): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This is a monomorphic function because it operates only on one type of data, namely strings.</p>
      <p>What if we wanted to search for an integer in a list of integers?</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;Int&gt;, key: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>With the exception of the parameter types, the code is exactly the same. Of course, it seems like a waste to create two separate functions that do the exact same thing, just with different types.</p>
      <p>Polymorphic functions are functions that operate on any type that it is given.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, key: A): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This function will work for strings, ints, doubles, anything really.</p>
      <div class="ln-box">
        <p>This type of polymorphism is called parametric polymorphism. Polymorphism in object-oriented programming is subtype polymorphism.</p>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
