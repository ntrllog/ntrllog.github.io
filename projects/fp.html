<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
                          _   _
     _  _    _     _  _  | | | |   __     ____
    | |/ \  | |_  | |/_| | | | |  /  \   /    \
    | |   | |  _| |  /   | | | | | || | |  ||  |
    | |   | | |_  | |    | | | | | || | |  ||  |
    |_|   | |___| |_|    |_| |_|  \__/   \____/|
                                               |
                                          ____/
    -->
    <title>ntrllog | Functional Programming</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../pictures/favicon.ico"/>
    <link href="../css/content.css" rel="stylesheet">
  </head>
  <body>
    <div class="dropdown ln-fixed-right">
      <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">ToC</button>
      <ul class="dropdown-menu">
        <li><a class="dropdown-item" href="#purefuncs">Pure Functions</a></li>
        <li><a class="dropdown-item" href="#dataimmutability">Data Immutability</a></li>
        <li><a class="dropdown-item" href="#whyfp">Why Functional Programming?</a></li>
        <li><a class="dropdown-item" href="#tailrecursion">Tail Recursion</a></li>
        <li><a class="dropdown-item" href="#currying">Currying</a></li>
        <li><a class="dropdown-item" href="#polymorphic">Polymorphic Functions</a></li>
        <li><a class="dropdown-item" href="#generics">Generics</a></li>
      </ul>
    </div>
    <div class="container ln-line-height">
      <a href="projects.html"><i class="fas fa-long-arrow-alt-left fa-2x"></i></a>
      <h1>Functional Programming</h1>
      <hr>
      <p>Shortcut to this page: <a href="fp.html">ntrllog.netlify.app/fp</a></p>
      <p>Notes provided by Professor John Hurley</p>
      <p>(all code examples are done in Kotlin with expression bodies when possible)</p>
      <h2 id="purefuncs">Pure Functions</h2>
      <p>A pure function is a function that:</p>
      <ul>
        <li>always returns the same value for the same input</li>
        <li>has no side effects</li>
      </ul>
      <h3>Referential Transparency</h3>
      <p>Consider the function:</p>
      <div class="ln-center">
        <p><code>fun doubleIt(n: Int): Int = n * 2</code></p>
      </div>
      <p>and consider the input `n=3`. We can see that for `n=3`, the output will always be `6` no matter what.</p>
      <p>This can be thought of as referential transparency, meaning that calls to the same function with the same arguments will always return the same value.</p>
      <div class="ln-box">
        <p>Technically, referential transparency refers to the ability to replace an expression with its value while still maintaining the correctness of the code. For example, if, for some reason, we had <code>doubleIt(3)</code> in our code, we could replace it with <code>6</code> and the program would still work the same way.</p>
        <div class="ln-center">
          <p><code>val x = doubleIt(3) // this line can be rewritten as val x = 6</code></p>
        </div>
        <p>This replacement is possible only because the function will always return the same value for the same input. Which is why the definition of referential transparency can be thought of this way.</p>
        <p>(In a way, the definition of referential transparency is referentially transparent? ü§îüòè)</p>
      </div>
      <h4>That's Not Very Referentially Transparent of You</h4>
      <p>An example of a function that's not referentially transparent is this:</p>
      <div class="ln-flex-center">
        <p><code>val cost = 0.73<br>fun getCost(n: Int): Double = n * cost</code></p>
      </div>
      <p>If the value of <code>cost</code> is changed, then <code>getCost()</code> will return something different for the same input.</p>
      <h3>Side Effects</h3>
      <p>Side effects are changes that are caused by a function call, but the changes themselves occur outside of the function call. These changes usually are not necessary for calculating the return value of the function (assuming, in the spirit of functional programming, that the primary purpose of a function is to return something rather than do something). Some examples of side effects are:</p>
      <ul>
        <li>modifying a variable beyond the scope of the block where the change occurs</li>
        <li>modifying a data structure in place</li>
        <li>setting a field on an object</li>
        <li>throwing an exception or halting with an error</li>
        <li>printing to the console</li>
        <li>reading user input</li>
        <li>reading from or writing to a file</li>
        <li>drawing on the screen</li>
      </ul>
      <p>This is an example of a function that modifies a variable outside of its scope (and prints):</p>
      <div class="ln-flex-center">
        <p><code>var counter = 0<br>fun incrementCounter() {<br>&nbsp;&nbsp;&nbsp;&nbsp;++counter<br>&nbsp;&nbsp;&nbsp;&nbsp;println(counter)<br>}</code></p>
      </div>
      <h2 id="dataimmutability">Data Immutability</h2>
      <p>In functional programming, data are not allowed to be changed* once it is created. So something as simple (and seemingly essential) as a loop is not allowed. Consider this loop:</p>
      <div class="ln-flex-center">
        <p><code>for (num in numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;squaredNums += listOf(num * num)<br>}</code></p>
      </div>
      <p><code>num</code> and <code>squaredNums</code> are being changed on every iteration of the loop, and data are not allowed to be changed!</p>
      <p>*Changed means reassigned to a different value.</p>
      <p>Instead of loops, recursion is used.</p>
      <p>In the context of lists, if we want a different list (e.g., one of the elements need to be changed or removed), then we need to create a new list instead of modifying the original list.</p>
      <div class="ln-flex-center">
        <p><code>val originalList = listOf(1, 2, 3, 4, 5)<br>val newList = originalList.slice(0..1) + originalList.slice(3..originalList.size-1) // newList = [1, 2, 4, 5]</code></p>
      </div>
      <h2 id="whyfp">Why Functional Programming?</h2>
      <p>With functional programming, there are no side effects; there are no mutable data; and there is referential transparency. All of these make functional programming great for concurrent programming because there is no shared state, data synchronization issues, race conditions, and deadlocks.</p>
      <p>The code is more modular since there is no shared state.</p>
      <p>Pure functions are less buggy than impure functions. Since they don't depend on external state, pure functions are more reliable once they are thoroughly tested. Pure functions also don't have side effects, so they don't create unpredictable problems.</p>
      <p>Referential transparency makes it possible to cache the result of a function call, so that the result can be used instead of calling the function again. (This is called memoization.)<p>
      <h2 id="tailrecursion">Tail Recursion</h2>
      <p>Whenever a function call is made, a stack is created for that function call. So for recursive functions, a stack is created for each recursive call.</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int = if (n &lt;= 1) n else n * factorial(n-1)</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/recursion.gif">
      </div>
      <p>If too many recursive calls are made, then too many stacks will be created, resulting in a stack overflow. Since we're pretty much limited to recursion in functional programming, we have to find a way to use recursion without running into a stack overflow.</p>
      <p>Well, we can avoid having too many stacks by getting rid of them once we don't need them anymore. Going back to the recursion animation above, notice that each stack after the main stack needs to allocate memory for an Int (the <code>n</code> in <code>n * factorial(n-1)</code>). This means that the recursive call is <em>not</em> the last thing that is performed in the stack (the multiplication is the last thing being performed). Because we need to store the <code>n</code> in each stack in order for the recursion to work, we cannot simply remove the stack after a recursive call. But it would be nice to be able to do so!</p>
      <p>So if we don't want to store anything in each stack, then that means we should push all the information we need to the next stack. Consider this modified factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3, 1)<br>}<br>fun factorial(n: Int, accumulator: Int): Int = if (n &lt;= 1) accumulator else factorial(n-1, n * accumulator)</code></p>
      </div>
      <p>This modification pushes the result of each multiplication forward (in the <code>accumulator</code>) so that it doesn't need to be stored.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.png">
        <p>(lol there's no animation here.)</p>
      </div>
      <p>Notice now that the recursive call <em>is</em> the last thing that is performed in the stack and that no memory needs to be allocated to store anything ‚Äî this is tail recursion! Capable compilers are able to take advantage of this and remove the previous stack on each recursive call ‚Äî after all, there's no important information being stored in the previous stack (this is tail-call elimination/optimization!)</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.gif">
      </div>
      <p>The fact that the stacks can be removed is nice, but this factorial function is a bit awkward. It's not intuitive to need two parameters to calculate the factorial of a number. In addition, if we accidentally put the wrong initial value for the accumulator, then the answer will be wrong.</p>
      <h3>Helper Function to the Rescue!</h3>
      <p>Consider this final version of the factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: Int, accumulator: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt;= 1) accumulator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x-1, x * accumulator)<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(n, 1)<br>}</code></p>
      </div>
      <p>Here, we have a nested function (<code>helper()</code>) that is called recursively. The outer function (<code>factorial()</code>) is no longer called recursively; instead it kicks off the recursive process. This allows the factorial function to be clean while still getting the benefits of tail-call elimination.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_2.gif">
      </div>
      <h3>A Systematic Approach to Making Functions Tail Recursive</h3>
      <p>There are three main ideas:</p>
      <ul>
        <li>there is an outer function that defines and calls an inner function, which is going to be the recursive one</li>
        <li>the inner function takes in an accumulator that starts with an initial value and builds up the result at each recursive step</li>
        <li>the base case returns the accumulator</li>
      </ul>
      <p>Let's look at string reversal as an example.</p>
      <p>There is an outer function:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {</code></p>
      </div>
      <p>That defines an inner function, which takes in an accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =</code></p>
      </div>
      <p>The base case returns the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc</code></p>
      </div>
      <p>The inner function is recursive and the accumulator builds up the result at each recursive step:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])</code></p>
      </div>
      <p>The outer function calls the inner function with an initial value for the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s, "")<br>}</code></p>
      </div>
      <div class="ln-box">
        <h2>A Different Way To Recurse</h2>
        <p>Now, I don't know about you, but when I learned about recursion, there was always some argument that would get smaller with each recursive call. For example, in the example above, the string being passed to the recursive helper function is getting smaller by one character each time until it is empty. I never really realized that this is not the only way to do things recursively.</p>
        <p>If working with strings or lists, then instead of making the string or list smaller in each recursive call, we can just pass an increasing (or decreasing) index instead. ü§Ø</p>
        <div class="ln-flex-center">
          <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt; 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(n-1, acc + s[n])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s.length-1, "")<br>}</code></p>
        </div>
      </div>
      <h2 id="currying">Currying</h2>
      <p>Currying is taking a function with multiple arguments and breaking it up into mutiple functions, each with one argument.</p>
      <p>(I feel like a function that adds two numbers is a very contrived and overused example, but let's roll with it!) Suppose we have a function that adds two numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun myAdd(x: Int, y: Int): Int = x + y</code></p>
      </div>
      <p>Now suppose we have a use case where we always want to add `5` to any number. Of course, we can simply just do <code>myAdd(x, 5)</code>, whenever we need to, but we can make the function calls simpler and clearer. The idea is to create a new function (let's call it <code>addFive()</code>) that takes in only one argument and adds `5` to it. Simpler and clearer.</p>
      <p>Time to curry the <code>myAdd()</code> function!</p>
      <div class="ln-flex-center">
        <p><code>fun addCurried(x: Int): (Int) -> Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(y: Int): Int = x + y<br>}<br>val add5 = addCurried(5)<br>val r = add5(10) // r = 15</code></p>
      </div>
      <p>We broke the <code>myAdd()</code> function into two smaller functions, each with one argument. The outer function takes in one of the arguments (<code>x</code>) and simply returns another function. That other function takes in the other argument (<code>y</code>) and does what the original <code>myAdd()</code> function would've done. Since the outer function returns a function, we can create new functions, like <code>add5()</code>.</p>
      <div class="ln-box">
        <h3>Closure</h3>
        <p>When we return from a function, everything in that function's scope gets destroyed. So it's interesting to note here that even when <code>addCurried()</code> returned, <code>add5()</code> still had access to the `5`, which was passed through <code>x</code>. Theoretically, <code>x</code> looks like it should've been inaccessible after <code>addCurried()</code> returned. But it isn't. A closure is a function that can access a variable that is defined outside of its scope, even after the outer function has returned.</p>
      </div>
      <p>Let's look at a more complicated, but more practical, example. Suppose we had our own filter function that filtered a list based on a custom function:</p>
      <div class="ln-flex-center">
        <p><code>fun myFilter(l: List&lt;Int&gt;, f: (Int) -> Boolean): List&lt;Int&gt; = l.filter(f)</code></p>
      </div>
      <p>Time to curry!</p>
      <div class="ln-flex-center">
        <p><code>fun filterCurried(f: (Int) -> Boolean): (List&lt;Int&gt;) -> List&lt;Int&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter(f)<br>}<br>val isEven = { n: Int -> n % 2 == 0 }<br>val filterEven = filterCurried(isEven)<br>println(filterEven(listOf(1, 2, 3, 4, 5, 6)) // prints [2, 4, 6]</code></p>
      </div>
      <p>With this example, we can see a more useful reason to use currying. Imagine if we wanted to create <code>filterEven()</code> and <code>filterOdd()</code> but without currying.</p>
      <div class="ln-flex-center">
        <p><code>fun filterEven(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 0}<br>fun filterOdd(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 1}</code></p>
      </div>
      <p>Notice how they're almost exactly the same. It seems like wasted repetition to create two similarly-defined functions this way.</p>
      <h2 id="polymorphic">Polymorphic Functions</h2>
      <p>Consider this function that searches for a string in a list of strings:</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;String&gt;, key: String): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This is a monomorphic function because it operates only on one type of data, namely strings.</p>
      <p>What if we wanted to search for an integer in a list of integers?</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;Int&gt;, key: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>With the exception of the parameter types, the code is exactly the same. Of course, it seems like a waste to create two separate functions that do the exact same thing, just with different types.</p>
      <p>Polymorphic functions are functions that operate on any type that it is given.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, key: A): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This function will work for strings, ints, doubles, anything really.</p>
      <div class="ln-box">
        <p>This type of polymorphism is called parametric polymorphism. Polymorphism in object-oriented programming is subtype polymorphism.</p>
      </div>
      <div class="ln-box">
        <h3>Predicate Functions</h3>
        <p>A predicate function is a pure function that returns either true or false. These are typically used as custom compare functions. For example, here is a predicate function (written as a lambda expression) that returns true if the input to the function contains the letter l:</p>
        <div class="ln-flex-center">
          <p><code>{ it.contains('l') }</code></p>
        </div>
        <p>So instead of being restricted to whatever condition is inside the when statement, we can pass our own compare function:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, f: (A) -&gt; Boolean): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(l.get(n)) -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>val i: Int = findFirst(l, { it.contains('l') })</code></p>
        </div>
      </div>
      <div class="ln-box">
        <p>Polymorphic functions are also called generic functions because the types are being abstracted.</p>
      </div>
      <div class="ln-box">
        <p>Quicksort is a sorting algorithm that starts with a pivot element, sorts the sublist that is "less than" the pivot element, sorts the sublist that is "greater than" the pivot element, and then combines them together to get a sorted list. Typically, the pivot is chosen randomly, but here we'll use the first element of the (sub)list(s) as the pivot.</p>
      </div>
      <p>Here's a pretty cool example of quicksort with generic types and a predicate function:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; quicksort(l: List&lt;A&gt;, f: (x: A, y: A) -&gt; Int): List&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l.size &lt;= 1) l<br>&nbsp;&nbsp;&nbsp;&nbsp;else quicksort(l.drop(1).filter{ f(it, l.get(0)) &lt; 0 }, f) + l.get(0) + quicksort(l.drop(1).filter{ f(it, l.get(0)) &gt;= 0 }, f)</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val l1 = listOf(41, 89, -10, 54, 16, 543, 4)<br>&nbsp;&nbsp;&nbsp;&nbsp;val l2 = listOf("pizza", "taco", "cheeseburger", "french fries", "popcorn", "pie")<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l1, {x, y -&gt; if(x &lt; y) -1 else if(x == y) 0 else 1 }))<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l2, {x, y -&gt; if(x.length &lt; y.length) -1 else if( x.length == y.length) 0 else 1}))<br>}</code></p>
      </div>
      <p>As convenient as it looks, we don't always want polymorphic functions to accept any type. To show why, here's a simple example:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>Obviously, this only works with number-like types; so if we pass in a string, things will go wrong. To prevent this, we can restrict the types that can be used as type arguments:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Number&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>This says that we can pass in any type for <code>A</code> as long as it is a Number type.</p>
      <p>A more practical example would be writing one compare function that works for multiple types, including custom classes:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Comparable&lt;A&gt;&gt; max(first: A, second: A): A = if (first.compareTo(second)) first else second</code></p>
      </div>
      <p>Here, we can pass in any type for <code>A</code> as long as it is Comparable.</p>
      <h2 id="generics">Generics</h2>
      <p>This naturally leads us to the concept of subtypes and supertypes. Suppose we have two types, `A` and `B`. Type `B` is a subtype of type `A` if you can use type `B` whenever type `A` is required. For example, Int is a subtype of Number; whenever the code expects a Number, we can pass an Int because technically, an Int is a Number.</p>
      <div class="ln-box">
        <p>This is the same as the concept of extending/implementing in object-oriented programming.</p>
      </div>
      <p>Now, there is this concept of a true subtype, which means that we can replace the supertype with the subtype without causing any errors. This means that:</p>
      <ul>
        <li>A subtype must accept all argument types that the supertype can accept</li>
        <li>A subtype must not return a result type that the supertype won't return</li>
      </ul>
      <p>(When I say subtype, I mean its functions.)</p>
      <p>(The following illustrations are adapted from <a href="https://typealias.com/guides/illustrated-guide-covariance-contravariance/" target="_blank">https://typealias.com/guides/illustrated-guide-covariance-contravariance/</a>. The information on covariance and contravariance is also from that website.)</p>
      <p>For example, suppose we had a supertype with a function that takes in a shape and returns a color. It only accepts one square or one circle and returns only green or blue.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype.png">
      </div>
      <p>In order for a type to be a true subtype of the supertype, we have to be able to replace the supertype with the subtype without causing errors. The first rule says that "a subtype must accept all argument types that the supertype can accept". Let's see what happens if we don't follow that rule, i.e., the subtype <em>does not</em> accept all argument types that the supertype can accept.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_2.png">
      </div>
      <p>In this case, the subtype only accepts circles. The supertype accepted squares, and the function call in main was expecting the code to work with passing in a square. But when we replaced the supertype with the subtype, the code broke. So the subtype is not a true subtype.</p>
      <p>Let's look at the second rule: "a subtype must not return a result type that the supertype won't return". Again, we'll see what happens when we don't follow that rule, i.e., the subtype <em>does</em> return a type that the supertype doesn't return.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_3.png">
      </div>
      <p>This time, the subtype can also return orange. The supertype only returned green or blue, and the function call in main was expecting only green or blue, not orange! So the subtype is not a true subtype.</p>
      <p>Now, this doesn't mean that if we want to create true subtypes, we have to create carbon copies of the supertype. (If this was the case, there wouldn't really be a point in creating subtypes in the first place.) Subtypes can be a little bit more flexible and still be a true subtype.</p>
      <h3>Contravariance</h3>
      <p>Let's change the first rule from "a subtype must accept all argument types that the supertype can accept" to "a subtype must accept <em>at least</em> the argument types that the supertype can accept". Under this new rule, the subtype still technically accepts "all" the argument types that the supertype can accept, just a little bit more.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/contravariance.png">
      </div>
      <p>And this is fine. Remember that the definition of a true subtype is that we can replace the supertype without causing any errors. As far as main is concerned, it is still interacting with the supertype, so main will continue to pass only squares and circles.</p>
      <p>This is called contravariance because as the type gets more specific ("narrower"), the type of arguments that can be accepted get more general ("expands"). They go in opposite directions, hence the "contra".</p>
      <h3>Covariance</h3>
      <p>Let's change the second rule from "a subtype must not return a result type that the supertype won't return" to "a subtype must return <em>at most</em> the same result types that the supertype returns". Under this new rule, the subtype can choose to exclude something the supertype returns.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/covariance.png">
      </div>
      <p>Again, this is fine because main is expecting either green or blue.</p>
      <p>This is called covariance because as the type gets more specific ("narrower"), the return types also get narrower. They go in the same direction, hence the "co".</p>
      <h3>New Rules!</h3>
      <p>So now the two rules for a subtype to be a true subtype are:</p>
      <ul>
        <li>A subtype must accept at least the argument types that the supertype can accept</li>
        <li>A subtype must return at most the same result types that the supertype returns</li>
      </ul>
      <h3>Variance</h3>
      <p>Variance is, at a very basic level, looking at if something is covariant or contravariant (or invariant, which we'll see right now).</p>
      <p>Since a String is a subtype of Any, is a MutableList of Strings a subtype of a MutableList of Anys?</p>
      <div class="ln-flex-center">
        <p><code>fun add42ToList(list: MutableList&lt;Any&gt;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;list.add(42)<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val strings = mutableListOf("abc")<br>&nbsp;&nbsp;&nbsp;&nbsp;add42ToList(strings)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(strings.maxBy{ it.length })<br>}</code></p>
      </div>
      <p>This doesn't compile, but if it did, there would be a runtime error when calling the length method on an Int. Since we can't replace a MutableList of Anys with a MutableList of Strings, a MutableList of Strings is <em>not</em> a subtype of a MutableList of Anys.</p>
      <p>In fact, MutableList is invariant on the type parameter. That is, for any two different types `A` and `B`, <code>MutableList&lt;A&gt;</code> isn't a subtype or a supertype of <code>MutableList&lt;B&gt;</code>.</p>
      <h3>Generic Variance</h3>
      <p>Suppose we have a generic class <code>Group&lt;T&gt;</code>. If `A` is a subtype of `B` and <code>Group&lt;A&gt;</code> is a subtype of <code>Group&lt;B&gt;</code>, then the Group class is covariant. The subtyping is preserved, hence the "co". On the other hand, if `A` is a subtype of `B` and <code>Group&lt;B&gt;</code> is a subtype of <code>Group&lt;A&gt;</code>, then the Group class is contravariant. The subtyping is reversed, hence the "contra".</p>
      <p>Now let's suppose that Group has two functions: insert() and fetch(). (Let's also suppose it's an interface instead of a class just so it compiles.)</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <p>Let's say we have two classes: an Animal class and a Dog class, where Dog is a subtype of Animal. If we want to make the Group class covariant, then <code>Group&lt;Dog&gt;</code> should be a subtype of <code>Group&lt;Animal&gt;</code>. Let's see what's involved in making that happen.</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p>The way things are right now, <code>Group&lt;Dog&gt;</code> is not a subtype of <code>Group&lt;Animal&gt;</code> because <code>Group&lt;Dog&gt;</code> does not accept at least the same argument types that <code>Group&lt;Animal&gt;</code> accepts. For example, we could pass in a Cat to <code>Group&lt;Animal&gt;</code>'s insert() function, but we can't pass a Cat to <code>Group&lt;Dog&gt;</code>'s insert() function. This means that in order to make <code>Group&lt;Dog&gt;</code> a subtype of <code>Group&lt;Animal&gt;</code>, <code>Group&lt;Dog&gt;</code>'s insert() function should accept an Animal:</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p><code>Group&lt;Dog&gt;</code> already returns at most the same result types that <code>Group&lt;Animal&gt;</code> returns, so that rule is not being broken.</p>
      <h3>Kotlin Variance Annotation</h3>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
