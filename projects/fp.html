<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
                          _   _
     _  _    _     _  _  | | | |   __     ____
    | |/ \  | |_  | |/_| | | | |  /  \   /    \
    | |   | |  _| |  /   | | | | | || | |  ||  |
    | |   | | |_  | |    | | | | | || | |  ||  |
    |_|   | |___| |_|    |_| |_|  \__/   \____/|
                                               |
                                          ____/
    -->
    <title>ntrllog | Functional Programming</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../pictures/favicon.ico"/>
    <link href="../css/content.css" rel="stylesheet">
  </head>
  <body>
    <div class="dropdown ln-fixed-right">
      <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">ToC</button>
      <ul class="dropdown-menu">
        <li><a class="dropdown-item" href="#kotlinbasics">Kotlin Basics</a></li>
        <li><a class="dropdown-item" href="#purefuncs">Pure Functions</a></li>
        <li><a class="dropdown-item" href="#dataimmutability">Data Immutability</a></li>
        <li><a class="dropdown-item" href="#whyfp">Why Functional Programming?</a></li>
        <li><a class="dropdown-item" href="#tailrecursion">Tail Recursion</a></li>
        <li><a class="dropdown-item" href="#currying">Currying</a></li>
        <li><a class="dropdown-item" href="#polymorphic">Polymorphic Functions</a></li>
        <li><a class="dropdown-item" href="#generics">Generics</a></li>
        <li><a class="dropdown-item" href="#abstractdatatypes">Abstract Data Types</a></li>
        <li><a class="dropdown-item" href="#functionaldatastructures">Functional Data Structures</a></li>
        <li><a class="dropdown-item" href="#errorhandling">Error Handling</a></li>
        <li><a class="dropdown-item" href="#strictnessnlaziness">Strictness and Laziness</a></li>
        <li><a class="dropdown-item" href="#corecursion">Corecursion</a></li>
        <li><a class="dropdown-item" href="#memoization">Memoization</a></li>
        <li><a class="dropdown-item" href="#functionalstate">Functional State</a></li>
      </ul>
    </div>
    <div class="container ln-line-height">
      <a href="projects.html"><i class="fas fa-long-arrow-alt-left fa-2x"></i></a>
      <h1>Functional Programming</h1>
      <hr>
      <p>Shortcut to this page: <a href="fp.html">ntrllog.netlify.app/fp</a></p>
      <p>Notes provided by Professor John Hurley</p>
      <p>(all code examples are done in Kotlin with expression bodies when possible)</p>
      <div class="ln-box">
        <h2 id="kotlinbasics">Kotlin Basics</h2>
        <p>Write code that uses recursion to calculate the sum of all integers from `1` to `n`, and print the result.</p>
        <div class="collapse ln-box" id="kotlin_basics_q1">
          <div class="ln-flex-center">
            <p><code>fun summation(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (n == 1) 1<br>&nbsp;&nbsp;&nbsp;&nbsp;else n + summation(n-1)</code></p>
          </div>
          <div class="ln-flex-center">
            <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;println(summation(4))<br>}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q1" aria-expanded="false" aria-controls="kotlin_basics_q1">Answer</button>
        <p>Write an <code>isPyth(a,b,c)</code> function with an expression body that takes three <code>Double</code>s as arguments and returns true if they are a Pythagorean triple, otherwise returns false. Use <code>Math.pow(base, exponent)</code>, where both <code>base</code> and <code>exponent</code> are <code>Double</code>s. <code>Double</code> has an <code>equals()</code> method; use that, not <code>==</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q2">
          <div class="ln-flex-center">
            <p><code>fun isPyth(a: Double, b: Double, c: Double): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;(Math.pow(a, 2.0) + Math.pow(b, 2.0)).equals(Math.pow(c, 2.0))</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q2" aria-expanded="false" aria-controls="kotlin_basics_q2">Answer</button>
        <p>Write a palindrome check function. Use this algorithm:</p>
        <ul>
          <li>if the length of the string is less than `2`, return true</li>
          <li>else if the first and last characters are not equal, return false</li>
          <li>else return the result of a recursive call with the substring from the second character (the one at index `1`) to the second to last character</li>
        </ul>
        <div class="collapse ln-box" id="kotlin_basics_q3">
          <div class="ln-flex-center">
            <p><code>fun isPalindrome(s: String): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s.length &lt; 2) true<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (s[0] != s[s.length-1]) false<br>&nbsp;&nbsp;&nbsp;&nbsp;else isPalindrome(s.substring(1, s.length-1))</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q3" aria-expanded="false" aria-controls="kotlin_basics_q3">Answer</button>
        <p>Write a function <code>getArea()</code> which takes a <code>Double</code> radius and returns the area of a circle with the given radius (<code>Math.PI</code> times radius ^ `2`).</p>
        <div class="collapse ln-box" id="kotlin_basics_q4">
          <div class="ln-flex-center">
            <p><code>fun getArea(r: Double): Double = Math.PI * r * r</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q4" aria-expanded="false" aria-controls="kotlin_basics_q4">Answer</button>
        <p>Write a recursive function that takes an <code>Int</code> `n` and returns a list of the areas of circles for each radius from `n` to `1` (in decreasing order.) Get the areas by calling the area function above. Then rewrite the recursive function so that the areas appear in increasing order.</p>
        <div class="collapse ln-box" id="kotlin_basics_q5">
          <div class="ln-flex-center">
            <p><code>fun getAreasDec(n: Int): List&lt;Double&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (n == 0) listOf()<br>&nbsp;&nbsp;&nbsp;&nbsp;else listOf(getArea(n.toDouble())) + getAreasDec(n-1)</code></p>
          </div>
          <div class="ln-flex-center">
            <p><code>fun getAreasInc(n: Int): List&lt;Double&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (n == 0) listOf()<br>&nbsp;&nbsp;&nbsp;&nbsp;else getAreasInc(n-1) + listOf(getArea(n.toDouble()))</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q5" aria-expanded="false" aria-controls="kotlin_basics_q5">Answer</button>
        <p>Create a list that uses the <code>getArea()</code> function as an initializer and contains the areas of circles with each integer from `1` to `25` as the radius.</p>
        <div class="collapse ln-box" id="kotlin_basics_q6">
          <div class="ln-flex-center">
            <p><code>val l = List&lt;Double&gt;(25){i -> getArea((i+1).toDouble())}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q6" aria-expanded="false" aria-controls="kotlin_basics_q6">Answer</button>
        <p>Create a list of <code>Int</code>s from `1` to `25`. Then use <code>map()</code> with the list and the <code>getArea()</code> function to create a list of the areas of circles with each of the <code>Int</code>s as the radius.</p>
        <div class="collapse ln-box" id="kotlin_basics_q7">
          <div class="ln-flex-center">
            <p><code>val l: List&lt;Int&gt; = (1..25).toList()<br>val m: List&lt;Double&gt; = l.map{getArea(it.toDouble())}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q7" aria-expanded="false" aria-controls="kotlin_basics_q7">Answer</button>
        <p>Using an initializer expression, create a list of the <code>Int</code>s from `0` to `25`, and another of the squares of the <code>Int</code>s from `0` to `25`. Then zip the two lists and print the result.</p>
        <div class="collapse ln-box" id="kotlin_basics_q8">
          <div class="ln-flex-center">
            <p><code>val l1 = List&lt;Int&gt;(26){it}<br>val l2 = List&lt;Int&gt;(26){it * it}<br>val l3 = l1.zip(l2)<br>println(l3)</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q8" aria-expanded="false" aria-controls="kotlin_basics_q8">Answer</button>
        <p>Write a recursive function that takes a list of <code>Pair</code>s in which each value may be of any type, and returns a list of the first elements from each pair.</p>
        <div class="collapse ln-box" id="kotlin_basics_q9">
          <div class="ln-flex-center">
            <p><code>fun firstOf(l: List&lt;Pair&lt;Any, Any&gt;&gt;): List&lt;Any&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l.isEmpty()) listOf()<br>&nbsp;&nbsp;&nbsp;&nbsp;else listOf(l[0].first) + firstOf(l.drop(1))</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q9" aria-expanded="false" aria-controls="kotlin_basics_q9">Answer</button>
        <p>Write one line of code that uses <code>filter()</code> and <code>zip()</code> to take two lists of <code>String</code>s and zip only those pairs in which each <code>String</code> is longer than four characters.</p>
        <div class="collapse ln-box" id="kotlin_basics_q10">
          <div class="ln-flex-center">
            <p><code>val l = l1.zip(l2).filter{it.first.length &gt; 4 && it.second.length &gt; 4}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q10" aria-expanded="false" aria-controls="kotlin_basics_q10">Answer</button>
        <p>Use <code>filter()</code> to create a list of <code>String</code>s that consists only of <code>String</code>s that contain the character 'r'.</p>
        <div class="collapse ln-box" id="kotlin_basics_q11">
          <div class="ln-flex-center">
            <p><code>val r = l.filter{"r" in it}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q11" aria-expanded="false" aria-controls="kotlin_basics_q11">Answer</button>
        <p>Write a recursive function called <code>myZip</code> that takes two lists of type <code>Any</code> and returns a <code>List</code> of <code>Pair</code>s in which each value may be any type. The pairs consist of corresponding elements in the two lists (the first element of the first list and the first element of the second list, etc). The base case should be that either (or both) of the original lists has length `1`, so that, if the lists have different length, the zipping stops when one of the lists runs out of values.</p>
        <div class="collapse ln-box" id="kotlin_basics_q12">
          <div class="ln-flex-center">
            <p><code>fun myZip(l1: List&lt;Any&gt;, l2: List&lt;Any&gt;): List&lt;Pair&lt;Any, Any&gt;&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l1.size == 1 || l2.size == 1) listOf(Pair&lt;Any, Any&gt;(l1[0], l2[0]))<br>&nbsp;&nbsp;&nbsp;&nbsp;else listOf(Pair&lt;Any, Any&gt;(l1[0], l2[0])) + myZip(l1.drop(1), l2.drop(1))</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q12" aria-expanded="false" aria-controls="kotlin_basics_q12">Answer</button>
        <p>Write a function <code>lengthGreaterThan()</code> that takes a <code>String</code> `s` and an <code>Int</code> `n` and returns true if the <code>String</code> is at least `n` characters long. Then revise the function so that it can accept null values. If it receives null as the parameter, it should return false.</p>
        <div class="collapse ln-box" id="kotlin_basics_q13">
          <div class="ln-flex-center">
            <p><code>fun lengthGreaterThan(s: String, n: Int): Boolean = s.length >= n</code></p>
          </div>
          <div class="ln-flex-center">
            <p><code>fun lengthGreaterThanVer2(s: String?, n: Int?): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s == null || n == null) false<br>&nbsp;&nbsp;&nbsp;&nbsp;else s.length >= n</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q13" aria-expanded="false" aria-controls="kotlin_basics_q13">Answer</button>
        <p>Write a recursive function <code>myFilter()</code> that takes a list of nullable <code>String</code>s and an <code>Int</code> and returns a list of just the <code>String</code>s from the original list that satisfies the above condition.</p>
        <div class="collapse ln-box" id="kotlin_basics_q14">
          <div class="ln-flex-center">
            <p><code>fun myFilter(l: List&lt;String?&gt;, n: Int): List&lt;String?&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l.isEmpty()) listOf()<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (lengthGreaterThanVer2(l[0], n)) listOf(l[0]) + myFilter(l.drop(1), n)<br>&nbsp;&nbsp;&nbsp;&nbsp;else myFilter(l.drop(1), n)</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q14" aria-expanded="false" aria-controls="kotlin_basics_q14">Answer</button>
        <p>Get the same result above by using <code>filter()</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q15">
          <div class="ln-flex-center">
            <p><code>l.filter{lengthGreaterThanVer2(it, n)}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q15" aria-expanded="false" aria-controls="kotlin_basics_q15">Answer</button>
        <p>Write code that declares two nullable <code>String</code> values, sets one to "Godzilla" and the other to null. Then, for each one, if it is not null, print the upper case version (use the <code>String</code> method <code>uppercase()</code>), but if it is null, print the <code>String</code> "nothing to print!". Do this in two different ways: once using if/else and once using both the safe call operator and the Elvis operator.</p>
        <div class="collapse ln-box" id="kotlin_basics_q16">
          <div class="ln-flex-center">
            <p><code>val s1: String = "Godzilla"<br>val s2: String? = null<br>for (s in listOf(s1, s2)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println(s.uppercase())<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println("nothing to print!")<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;println(s?.uppercase() ?: "nothing to print!")<br>}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q16" aria-expanded="false" aria-controls="kotlin_basics_q16">Answer</button>
        <p>Write a function called <code>isLong()</code> that takes one argument whose type is <code>Any</code> and returns whether or not the value is a <code>Long</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q17">
          <div class="ln-flex-center">
            <p><code>fun isLong(a: Any): Boolean = a is Long</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q17" aria-expanded="false" aria-controls="kotlin_basics_q17">Answer</button>
        <p>Use <code>as</code> once in a way that will correctly cast from <code>Any</code> to a specific type, and once in a way that will throw an exception.</p>
        <div class="collapse ln-box" id="kotlin_basics_q18">
          <div class="ln-flex-center">
            <p><code>val s1: Any = "hi"<br>val s2: Any = 43<br>val s3: String = s1 as String<br>val s4: String = s2 as String</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q18" aria-expanded="false" aria-controls="kotlin_basics_q18">Answer</button>
        <p>Let's say we have this color <code>Enum</code>:</p>
        <div class="ln-flex-center">
          <p><code>enum class Color {<br>&nbsp;&nbsp;&nbsp;&nbsp;RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET<br>}</code></p>
        </div>
        <p>Create a <code>Monster</code> data class. A monster has a name, height, and favorite color. The class should also have a property called <code>isNamedGodzilla</code>, with an accessor that will return true if the monster is named Godzilla, else false. The class should also have a <code>heightRatio()</code> function, which takes another <code>Monster</code> as a parameter and returns the ratio of the instance monster's height to that of the parameter <code>Monster</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q19">
          <div class="ln-flex-center">
            <p><code>data class Monster(val name: String, val height: Double, val favColor: Color) {<br>&nbsp;&nbsp;&nbsp;&nbsp;val isNamedGodzilla: Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name == "Godzilla"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fun heightRatio(m: Monster): Double = this.height / m.height<br>}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q19" aria-expanded="false" aria-controls="kotlin_basics_q19">Answer</button>
        <p>Write a recursive linear search function that takes a <code>String</code> and a <code>Char</code> and returns true if the <code>String</code> contains the <code>Char</code>. The base cases are that a) the length of the <code>String</code> is `0` or b) the first character in the <code>String</code> is the character we are searching for.</p>
        <div class="collapse ln-box" id="kotlin_basics_q20">
          <div class="ln-flex-center">
            <p><code>fun linSearch(s: String, c: Char): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s.length == 0) false<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (s[0] == c) true<br>&nbsp;&nbsp;&nbsp;&nbsp;else linSearch(s.drop(1), c)</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q20" aria-expanded="false" aria-controls="kotlin_basics_q20">Answer</button>
        <p>Modify the linear search function so that both the <code>String</code> and the <code>Char</code> are nullable.  If either is null, return false.</p>
        <div class="collapse ln-box" id="kotlin_basics_q21">
          <div class="ln-flex-center">
            <p><code>fun linSearch(s: String?, c: Char?): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (s == null || c == null) false<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (s.length == 0) false<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (s[0] == c) true<br>&nbsp;&nbsp;&nbsp;&nbsp;else linSearch(s.drop(1), c)</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q21" aria-expanded="false" aria-controls="kotlin_basics_q21">Answer</button>
        <p>Write code that creates a list of nullable Strings.</p>
        <div class="collapse ln-box" id="kotlin_basics_q22">
          <div class="ln-flex-center">
            <p><code>val l: List&lt;String?&gt; = listOf("hey", null, "hi", null)</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q22" aria-expanded="false" aria-controls="kotlin_basics_q22">Answer</button>
        <p>Write the function <code>divIntSafe(a: Int, b:Int)</code>. This function should take two <code>Int</code>s, convert them to <code>Double</code>s, divide the first by the second, and return the result.</p>
        <div class="collapse ln-box" id="kotlin_basics_q23">
          <div class="ln-flex-center">
            <p><code>fun divIntSafe(a: Int, b: Int): Double = a.toDouble() / b.toDouble()</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q23" aria-expanded="false" aria-controls="kotlin_basics_q23">Answer</button>
        <p>Write code that creates a list of the inverses of the Ints from `1` to `10`. Do this in two ways: using a lambda expression as the initializer expression and using <code>divIntSafe()</code> as the initializer expression.</p>
        <div class="collapse ln-box" id="kotlin_basics_q24">
          <div class="ln-flex-center">
            <p><code>val l1: List&lt;Double&gt; = List&lt;Double&gt;(10){1/(it + 1).toDouble()}</code></p>
          </div>
          <div class="ln-flex-center">
            <p><code>val l2: List&lt;Double&gt; = List&lt;Double&gt;(10){divIntSafe(1, it+1)}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q24" aria-expanded="false" aria-controls="kotlin_basics_q24">Answer</button>
        <p>Write code that declares a nullable <code>Int</code> (give it a value), then declares a nullable <code>Double</code> and uses the safe call operator to set its value to null if the nullable <code>Int</code> was null, else to the result of casting the <code>Int</code> to a <code>Double</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q25">
          <div class="ln-flex-center">
            <p><code>val n: Int? = null<br>val d: Double? = n?.toDouble()</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q25" aria-expanded="false" aria-controls="kotlin_basics_q25">Answer</button>
        <p>Write code that declares a nullable <code>Int</code> (give it a value), then declares a nullable <code>Double</code> and uses the safe call operator and the Elvis operator to set its value to `0.0` if the nullable <code>Int</code> was null, else to the result of casting the <code>Int</code> to a <code>Double</code>.</p>
        <div class="collapse ln-box" id="kotlin_basics_q26">
          <div class="ln-flex-center">
            <p><code>val n: Int? = null<br>val d: Double? = n?.toDouble() ?: 0.0</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#kotlin_basics_q26" aria-expanded="false" aria-controls="kotlin_basics_q26">Answer</button>
      </div>
      <h2 id="purefuncs">Pure Functions</h2>
      <p>A pure function is a function that:</p>
      <ul>
        <li>always returns the same value for the same input</li>
        <li>has no side effects</li>
      </ul>
      <h3>Referential Transparency</h3>
      <p>Consider the function:</p>
      <div class="ln-center">
        <p><code>fun doubleIt(n: Int): Int = n * 2</code></p>
      </div>
      <p>and consider the input `n=3`. We can see that for `n=3`, the output will always be `6` no matter what.</p>
      <p>This can be thought of as referential transparency, meaning that calls to the same function with the same arguments will always return the same value.</p>
      <div class="ln-box">
        <p>Technically, referential transparency refers to the ability to replace an expression with its value while still maintaining the correctness of the code. For example, if, for some reason, we had <code>doubleIt(3)</code> in our code, we could replace it with <code>6</code> and the program would still work the same way.</p>
        <div class="ln-center">
          <p><code>val x = doubleIt(3) // this line can be rewritten as val x = 6</code></p>
        </div>
        <p>This replacement is possible only because the function will always return the same value for the same input. Which is why the definition of referential transparency can be thought of this way.</p>
        <p>(In a way, the definition of referential transparency is referentially transparent? 🤔😏)</p>
      </div>
      <h4>That's Not Very Referentially Transparent of You</h4>
      <p>An example of a function that's not referentially transparent is this:</p>
      <div class="ln-flex-center">
        <p><code>val cost = 0.73<br>fun getCost(n: Int): Double = n * cost</code></p>
      </div>
      <p>If the value of <code>cost</code> is changed, then <code>getCost()</code> will return something different for the same input.</p>
      <h3>Side Effects</h3>
      <p>Side effects are changes that are caused by a function call, but the changes themselves occur outside of the function call. These changes usually are not necessary for calculating the return value of the function (assuming, in the spirit of functional programming, that the primary purpose of a function is to return something rather than do something). Some examples of side effects are:</p>
      <ul>
        <li>modifying a variable beyond the scope of the block where the change occurs</li>
        <li>modifying a data structure in place</li>
        <li>setting a field on an object</li>
        <li>throwing an exception or halting with an error</li>
        <li>printing to the console</li>
        <li>reading user input</li>
        <li>reading from or writing to a file</li>
        <li>drawing on the screen</li>
      </ul>
      <p>This is an example of a function that modifies a variable outside of its scope (and prints):</p>
      <div class="ln-flex-center">
        <p><code>var counter = 0<br>fun incrementCounter() {<br>&nbsp;&nbsp;&nbsp;&nbsp;++counter<br>&nbsp;&nbsp;&nbsp;&nbsp;println(counter)<br>}</code></p>
      </div>
      <h2 id="dataimmutability">Data Immutability</h2>
      <p>In functional programming, data are not allowed to be changed* once it is created. So something as simple (and seemingly essential) as a loop is not allowed. Consider this loop:</p>
      <div class="ln-flex-center">
        <p><code>for (num in numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;squaredNums += listOf(num * num)<br>}</code></p>
      </div>
      <p><code>num</code> and <code>squaredNums</code> are being changed on every iteration of the loop, and data are not allowed to be changed!</p>
      <p>*Changed means reassigned to a different value.</p>
      <p>Instead of loops, recursion is used.</p>
      <p>In the context of lists, if we want a different list (e.g., one of the elements need to be changed or removed), then we need to create a new list instead of modifying the original list.</p>
      <div class="ln-flex-center">
        <p><code>val originalList = listOf(1, 2, 3, 4, 5)<br>val newList = originalList.slice(0..1) + originalList.slice(3..originalList.size-1) // newList = [1, 2, 4, 5]</code></p>
      </div>
      <h2 id="whyfp">Why Functional Programming?</h2>
      <p>With functional programming, there are no side effects; there are no mutable data; and there is referential transparency. All of these make functional programming great for concurrent programming because there is no shared state, data synchronization issues, race conditions, and deadlocks.</p>
      <p>The code is more modular since there is no shared state.</p>
      <p>Pure functions are less buggy than impure functions. Since they don't depend on external state, pure functions are more reliable once they are thoroughly tested. Pure functions also don't have side effects, so they don't create unpredictable problems.</p>
      <p>Referential transparency makes it possible to cache the result of a function call, so that the result can be used instead of calling the function again. (This is called memoization.)<p>
      <h2 id="tailrecursion">Tail Recursion</h2>
      <p>Whenever a function call is made, a stack is created for that function call. So for recursive functions, a stack is created for each recursive call.</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int = if (n &lt;= 1) n else n * factorial(n-1)</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/recursion.gif">
      </div>
      <p>If too many recursive calls are made, then too many stacks will be created, resulting in a stack overflow. Since we're pretty much limited to recursion in functional programming, we have to find a way to use recursion without running into a stack overflow.</p>
      <p>Well, we can avoid having too many stacks by getting rid of them once we don't need them anymore. Going back to the recursion animation above, notice that each stack after the main stack needs to allocate memory for an Int (the <code>n</code> in <code>n * factorial(n-1)</code>). This means that the recursive call is <em>not</em> the last thing that is performed in the stack (the multiplication is the last thing being performed). Because we need to store the <code>n</code> in each stack in order for the recursion to work, we cannot simply remove the stack after a recursive call. But it would be nice to be able to do so!</p>
      <p>So if we don't want to store anything in each stack, then that means we should push all the information we need to the next stack. Consider this modified factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3, 1)<br>}<br>fun factorial(n: Int, accumulator: Int): Int = if (n &lt;= 1) accumulator else factorial(n-1, n * accumulator)</code></p>
      </div>
      <p>This modification pushes the result of each multiplication forward (in the <code>accumulator</code>) so that it doesn't need to be stored.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.png">
        <p>(lol there's no animation here.)</p>
      </div>
      <p>Notice now that the recursive call <em>is</em> the last thing that is performed in the stack and that no memory needs to be allocated to store anything — this is tail recursion! Capable compilers are able to take advantage of this and remove the previous stack on each recursive call — after all, there's no important information being stored in the previous stack (this is tail-call elimination/optimization!)</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.gif">
      </div>
      <p>The fact that the stacks can be removed is nice, but this factorial function is a bit awkward. It's not intuitive to need two parameters to calculate the factorial of a number. In addition, if we accidentally put the wrong initial value for the accumulator, then the answer will be wrong.</p>
      <h3>Helper Function to the Rescue!</h3>
      <p>Consider this final version of the factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: Int, accumulator: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt;= 1) accumulator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x-1, x * accumulator)<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(n, 1)<br>}</code></p>
      </div>
      <p>Here, we have a nested function (<code>helper()</code>) that is called recursively. The outer function (<code>factorial()</code>) is no longer called recursively; instead it kicks off the recursive process. This allows the factorial function to be clean while still getting the benefits of tail-call elimination.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_2.gif">
      </div>
      <h3>A Systematic Approach to Making Functions Tail Recursive</h3>
      <p>There are three main ideas:</p>
      <ul>
        <li>there is an outer function that defines and calls an inner function, which is going to be the recursive one</li>
        <li>the inner function takes in an accumulator that starts with an initial value and builds up the result at each recursive step</li>
        <li>the base case returns the accumulator</li>
      </ul>
      <p>Let's look at string reversal as an example.</p>
      <p>There is an outer function:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {</code></p>
      </div>
      <p>That defines an inner function, which takes in an accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =</code></p>
      </div>
      <p>The base case returns the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc</code></p>
      </div>
      <p>The inner function is recursive and the accumulator builds up the result at each recursive step:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])</code></p>
      </div>
      <p>The outer function calls the inner function with an initial value for the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s, "")<br>}</code></p>
      </div>
      <div class="ln-box">
        <h2>A Different Way To Recurse</h2>
        <p>Now, I don't know about you, but when I learned about recursion, there was always some argument that would get smaller with each recursive call. For example, in the example above, the string being passed to the recursive helper function is getting smaller by one character each time until it is empty. I never really realized that this is not the only way to do things recursively.</p>
        <p>If working with strings or lists, then instead of making the string or list smaller in each recursive call, we can just pass an increasing (or decreasing) index instead. 🤯</p>
        <div class="ln-flex-center">
          <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt; 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(n-1, acc + s[n])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s.length-1, "")<br>}</code></p>
        </div>
      </div>
      <h2 id="currying">Currying</h2>
      <p>Currying is taking a function with multiple arguments and breaking it up into mutiple functions, each with one argument.</p>
      <p>(I feel like a function that adds two numbers is a very contrived and overused example, but let's roll with it!) Suppose we have a function that adds two numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun myAdd(x: Int, y: Int): Int = x + y</code></p>
      </div>
      <p>Now suppose we have a use case where we always want to add `5` to any number. Of course, we can simply just do <code>myAdd(x, 5)</code>, whenever we need to, but we can make the function calls simpler and clearer. The idea is to create a new function (let's call it <code>addFive()</code>) that takes in only one argument and adds `5` to it. Simpler and clearer.</p>
      <p>Time to curry the <code>myAdd()</code> function!</p>
      <div class="ln-flex-center">
        <p><code>fun addCurried(x: Int): (Int) -> Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(y: Int): Int = x + y<br>}<br>val add5 = addCurried(5)<br>val r = add5(10) // r = 15</code></p>
      </div>
      <p>We broke the <code>myAdd()</code> function into two smaller functions, each with one argument. The outer function takes in one of the arguments (<code>x</code>) and simply returns another function. That other function takes in the other argument (<code>y</code>) and does what the original <code>myAdd()</code> function would've done. Since the outer function returns a function, we can create new functions, like <code>add5()</code>.</p>
      <div class="ln-box">
        <h3>Closure</h3>
        <p>When we return from a function, everything in that function's scope gets destroyed. So it's interesting to note here that even when <code>addCurried()</code> returned, <code>add5()</code> still had access to the `5`, which was passed through <code>x</code>. Theoretically, <code>x</code> looks like it should've been inaccessible after <code>addCurried()</code> returned. But it isn't. A closure is a function that can access a variable that is defined outside of its scope, even after the outer function has returned.</p>
      </div>
      <p>Let's look at a more complicated, but more practical, example. Suppose we had our own filter function that filtered a list based on a custom function:</p>
      <div class="ln-flex-center">
        <p><code>fun myFilter(l: List&lt;Int&gt;, f: (Int) -> Boolean): List&lt;Int&gt; = l.filter(f)</code></p>
      </div>
      <p>Time to curry!</p>
      <div class="ln-flex-center">
        <p><code>fun filterCurried(f: (Int) -> Boolean): (List&lt;Int&gt;) -> List&lt;Int&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter(f)<br>}<br>val isEven = { n: Int -> n % 2 == 0 }<br>val filterEven = filterCurried(isEven)<br>println(filterEven(listOf(1, 2, 3, 4, 5, 6)) // prints [2, 4, 6]</code></p>
      </div>
      <p>With this example, we can see a more useful reason to use currying. Imagine if we wanted to create <code>filterEven()</code> and <code>filterOdd()</code> but without currying.</p>
      <div class="ln-flex-center">
        <p><code>fun filterEven(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 0}<br>fun filterOdd(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 1}</code></p>
      </div>
      <p>Notice how they're almost exactly the same. It seems like wasted repetition to create two similarly-defined functions this way.</p>
      <h2 id="polymorphic">Polymorphic Functions</h2>
      <p>Consider this function that searches for a string in a list of strings:</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;String&gt;, key: String): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This is a monomorphic function because it operates only on one type of data, namely strings.</p>
      <p>What if we wanted to search for an integer in a list of integers?</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;Int&gt;, key: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>With the exception of the parameter types, the code is exactly the same. Of course, it seems like a waste to create two separate functions that do the exact same thing, just with different types.</p>
      <p>Polymorphic functions are functions that operate on any type that it is given.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, key: A): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This function will work for strings, ints, doubles, anything really.</p>
      <div class="ln-box">
        <p>This type of polymorphism is called parametric polymorphism. Polymorphism in object-oriented programming is subtype polymorphism.</p>
      </div>
      <div class="ln-box">
        <h3>Predicate Functions</h3>
        <p>A predicate function is a pure function that returns either true or false. These are typically used as custom compare functions. For example, here is a predicate function (written as a lambda expression) that returns true if the input to the function contains the letter l:</p>
        <div class="ln-flex-center">
          <p><code>{ it.contains('l') }</code></p>
        </div>
        <p>So instead of being restricted to whatever condition is inside the when statement, we can pass our own compare function:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, f: (A) -&gt; Boolean): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(l.get(n)) -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>val i: Int = findFirst(l, { it.contains('l') })</code></p>
        </div>
      </div>
      <div class="ln-box">
        <p>Polymorphic functions are also called generic functions because the types are being abstracted.</p>
      </div>
      <div class="ln-box">
        <p>Quicksort is a sorting algorithm that starts with a pivot element, sorts the sublist that is "less than" the pivot element, sorts the sublist that is "greater than" the pivot element, and then combines them together to get a sorted list. Typically, the pivot is chosen randomly, but here we'll use the first element of the (sub)list(s) as the pivot.</p>
      </div>
      <p>Here's a pretty cool example of quicksort with generic types and a predicate function:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; quicksort(l: List&lt;A&gt;, f: (x: A, y: A) -&gt; Int): List&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l.size &lt;= 1) l<br>&nbsp;&nbsp;&nbsp;&nbsp;else quicksort(l.drop(1).filter{ f(it, l.get(0)) &lt; 0 }, f) + l.get(0) + quicksort(l.drop(1).filter{ f(it, l.get(0)) &gt;= 0 }, f)</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val l1 = listOf(41, 89, -10, 54, 16, 543, 4)<br>&nbsp;&nbsp;&nbsp;&nbsp;val l2 = listOf("pizza", "taco", "cheeseburger", "french fries", "popcorn", "pie")<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l1, {x, y -&gt; if(x &lt; y) -1 else if(x == y) 0 else 1 }))<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l2, {x, y -&gt; if(x.length &lt; y.length) -1 else if( x.length == y.length) 0 else 1}))<br>}</code></p>
      </div>
      <p>As convenient as it looks, we don't always want polymorphic functions to accept any type. To show why, here's a simple example:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>Obviously, this only works with number-like types; so if we pass in a string, things will go wrong. To prevent this, we can restrict the types that can be used as type arguments:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Number&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>This says that we can pass in any type for <code>A</code> as long as it is a Number type.</p>
      <p>A more practical example would be writing one compare function that works for multiple types, including custom classes:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Comparable&lt;A&gt;&gt; max(first: A, second: A): A = if (first.compareTo(second)) first else second</code></p>
      </div>
      <p>Here, we can pass in any type for <code>A</code> as long as it is Comparable.</p>
      <h2 id="generics">Generics</h2>
      <p>This naturally leads us to the concept of subtypes and supertypes. Suppose we have two types, `A` and `B`. Type `B` is a subtype of type `A` if you can use type `B` whenever type `A` is required. For example, Int is a subtype of Number; whenever the code expects a Number, we can pass an Int because technically, an Int is a Number.</p>
      <p>To be a little more precise, in order for a type to be a true subtype (i.e., in order to fit the actual definition of what it means to be a subtype), we must be able to replace the supertype with the subtype without causing any errors. This means that:</p>
      <ul>
        <li>A subtype must accept all argument types that the supertype can accept</li>
        <li>A subtype must not return a result type that the supertype won't return</li>
      </ul>
      <p>(When I say subtype and supertype here, I mean their functions.)</p>
      <p>(The following illustrations are adapted from <a href="https://typealias.com/guides/illustrated-guide-covariance-contravariance/" target="_blank">https://typealias.com/guides/illustrated-guide-covariance-contravariance/</a>. Most of the information in this section is also from that website.)</p>
      <p>For example, suppose we had a supertype with a function that takes in a shape and returns a color. It only accepts one square or one circle and returns only green or blue.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype.png">
      </div>
      <p>In order for a type to be a true subtype of the supertype, we have to be able to replace the supertype with the subtype without causing errors. The first rule says that "a subtype must accept all argument types that the supertype can accept". Let's see what happens if we don't follow that rule, i.e., the subtype <em>does not</em> accept all argument types that the supertype can accept.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_2.png">
      </div>
      <p>In this case, the subtype only accepts circles. The supertype accepted squares, and the function call in main was expecting the code to work with passing in a square. But when we replaced the supertype with the subtype, the code broke. So the subtype is not a true subtype.</p>
      <p>Let's look at the second rule: "a subtype must not return a result type that the supertype won't return". Again, we'll see what happens when we don't follow that rule, i.e., the subtype <em>does</em> return a type that the supertype doesn't return.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_3.png">
      </div>
      <p>This time, the subtype can also return orange. The supertype only returned green or blue, and the function call in main was expecting only green or blue, not orange! So the subtype is not a true subtype.</p>
      <p>Now, this doesn't mean that if we want to create true subtypes, we have to create carbon copies of the supertype. (If this was the case, there wouldn't really be a point in creating subtypes in the first place.) Subtypes can be a little bit more flexible and still be a true subtype.</p>
      <h3>Contravariance</h3>
      <p>Let's change the first rule from "a subtype must accept all argument types that the supertype can accept" to "a subtype must accept <em>at least</em> the argument types that the supertype can accept". Under this new rule, the subtype still technically accepts "all" the argument types that the supertype can accept, just a little bit more.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/contravariance.png">
      </div>
      <p>And this is fine. Remember that the definition of a true subtype is that we can replace the supertype without causing any errors. As far as main is concerned, it is still interacting with the supertype, so main will continue to pass only squares and circles.</p>
      <p>This is called contravariance because as the type gets more specific ("narrower"), the type of arguments that can be accepted get more general ("expands"). They go in opposite directions, hence the "contra".</p>
      <h3>Covariance</h3>
      <p>Let's change the second rule from "a subtype must not return a result type that the supertype won't return" to "a subtype must return <em>at most</em> the same result types that the supertype returns". Under this new rule, the subtype can choose to exclude something the supertype returns.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/covariance.png">
      </div>
      <p>Again, this is fine because main is expecting either green or blue.</p>
      <p>This is called covariance because as the type gets more specific ("narrower"), the return types also get narrower. They go in the same direction, hence the "co".</p>
      <h3>New Rules!</h3>
      <p>So now the two rules for a subtype to be a true subtype are:</p>
      <ul>
        <li>A subtype must accept at least the argument types that the supertype can accept</li>
        <li>A subtype must return at most the same result types that the supertype returns</li>
      </ul>
      <h3>Variance</h3>
      <p>Variance is, at a very basic level, looking at if something is covariant or contravariant (or invariant, which we'll see right now).</p>
      <p>Since a String is a subtype of Any, is a MutableList of Strings a subtype of a MutableList of Anys?</p>
      <div class="ln-flex-center">
        <p><code>fun add42ToList(list: MutableList&lt;Any&gt;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;list.add(42)<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val strings = mutableListOf("abc")<br>&nbsp;&nbsp;&nbsp;&nbsp;add42ToList(strings)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(strings.maxBy{ it.length })<br>}</code></p>
      </div>
      <p>This doesn't compile, but if it did, there would be a runtime error when calling the length method on an Int. Since we can't replace a MutableList of Anys with a MutableList of Strings, a MutableList of Strings is <em>not</em> a subtype of a MutableList of Anys.</p>
      <p>In fact, MutableList is invariant on the type parameter. That is, for any two different types `A` and `B`, <code>MutableList&lt;A&gt;</code> isn't a subtype or a supertype of <code>MutableList&lt;B&gt;</code>.</p>
      <h3>Generic Variance (Covariance)</h3>
      <p>Suppose we have a generic class <code>Group&lt;T&gt;</code>. If `A` is a subtype of `B` and <code>Group&lt;A&gt;</code> is a subtype of <code>Group&lt;B&gt;</code>, then the Group class is covariant. The subtyping is preserved, hence the "co".</p>
      <p>Now let's suppose that Group has two functions: insert() and fetch(). (Let's also suppose it's an interface instead of a class just so it compiles.)</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <p>Let's say we have two classes: an Animal class and a Dog class, where Dog is a subtype of Animal. If we want to make the Group class covariant, then <code>Group&lt;Dog&gt;</code> should be a subtype of <code>Group&lt;Animal&gt;</code>. Let's see what we have so far and see if it's possible.</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p>The way things are right now, <code>Group&lt;Dog&gt;</code> is not a subtype of <code>Group&lt;Animal&gt;</code> because <code>Group&lt;Dog&gt;</code> does not accept at least the same argument types that <code>Group&lt;Animal&gt;</code> accepts. For example, we could pass in a Cat to <code>Group&lt;Animal&gt;</code>'s insert() function, but we can't pass a Cat to <code>Group&lt;Dog&gt;</code>'s insert() function.</p>
      <p>Note that <code>Group&lt;Dog&gt;</code> already returns at most the same result types that <code>Group&lt;Animal&gt;</code> returns, so that rule is not being broken.</p>
      <h3>Kotlin Variance Annotation (out)</h3>
      <p>For now, let's remove the insert() function so that the first rule is not broken.</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p>Since both subtyping rules are not being broken anymore, <code>Group&lt;Dog&gt;</code> <em>is</em> a subtype of <code>Group&lt;Animal&gt;</code>. To tell Kotlin that we want to treat <code>Group&lt;Dog&gt;</code> as a subtype of <code>Group&lt;Animal&gt;</code>, we use the <code>out</code> annotation:</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;out T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>It's called "out" because the type is used only as an output.</p>
      </div>
      <div class="ln-box">
        <p>If we were to add the insert() function back, we would get a compile-time error: "Type parameter T is declared as 'out' but occurs in 'in' position in type T".</p>
        <div class="ln-flex-center">
          <p><code>interface Group&lt;out T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
        </div>
        <p>And as we just saw, this is because this violates the first subtype rule about accepting at least all of the supertype's arguments.</p>
        <p>(Note that adding the <code>out</code> modifier prevents us from creating any functions that take the type as a parameter, and therefore, breaking the above rule.)</p>
      </div>
      <h3>Generic Variance (Contravariance)</h3>
      <p>On the other hand, if `A` is a subtype of `B` and <code>Group&lt;B&gt;</code> is a subtype of <code>Group&lt;A&gt;</code>, then the Group class is contravariant. The subtyping is reversed, hence the "contra".</p>
      <p>If we want to make the Group class contravariant, then <code>Group&lt;Animal&gt;</code> should be a subtype of <code>Group&lt;Dog&gt;</code>. Let's see what we have so far and see if it's possible.</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}<br>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}</pre></p>
      </div>
      <p>Well, <code>Group&lt;Animal&gt;</code> does accept at least the same argument types as <code>Group&lt;Dog&gt;</code> does, so that rule is fine. However, <code>Group&lt;Animal&gt;</code> can return more types than <code>Group&lt;Dog&gt;</code> can. So the second rule is being broken!</p>
      <h3>Kotlin Variance Annotation (in)</h3>
      <p>Similarly to before, let's remove the fetch() function so that the second subtyping rule is not broken.</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>}<br>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>}</pre></p>
      </div>
      <p>Now both subtyping rules are not being broken anymore, so <code>Group&lt;Animal&gt;</code> <em>is</em> a subtype of <code>Group&lt;Dog&gt;</code>. To tell Kotlin that we want to treat <code>Group&lt;Animal&gt;</code> as a subtype of <code>Group&lt;Dog&gt;</code>, we use the <code>in</code> annotation:</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;in T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>It's called "in" because the type is used only as an input.</p>
      </div>
      <div class="ln-box">
        <p>If we were to add the fetch() function back, we would get a compile-time error: "Type parameter T is declared as 'in' but occurs in 'out' position in type T".</p>
        <div class="ln-flex-center">
          <p><code>interface Group&lt;in T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
        </div>
        <p>And as we just saw, this is because this violates the second subtype rule about returning at most all of the supertype's arguments.</p>
        <p>(Note that adding the <code>in</code> modifier prevents us from creating any functions that return the type, and therefore, breaking the above rule.)</p>
      </div>
      <div class="ln-box">
        <h3>Another Example With Squares</h3>
        <h4>Out</h4>
        <p>Suppose we had a Square class that can hold an item and return it:</p>
        <div class="ln-flex-center">
          <p><code>class Square&lt;out T&gt;(private val item: T) {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun getItem(): T = item<br>}</code></p>
        </div>
        <p>Let's look at what we are allowed to do with this Square. This first line is nothing special; we can assign a <code>Square&lt;Int&gt;</code> to a variable of type <code>Square&lt;Int&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>}</code></p>
        </div>
        <p>The next line is where it starts to get interesting. We can assign a <code>Square&lt;Int&gt;</code> to a variable of type <code>Square&lt;Number&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = intSquare<br>}</code></p>
        </div>
        <p>This is okay because the Square class is covariant (because of the <code>out</code> modifier); so <code>Square&lt;Int&gt;</code> is a subtype of <code>Square&lt;Number&gt;</code>.</p>
        <p><code>Square&lt;Number&gt;</code> can also call <code>getItem()</code> without any errors because the subtype (<code>Square&lt;Int&gt;</code>) does not return any values that the supertype (<code>Square&lt;Number&gt;</code>) doesn't return.</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = intSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;println(numSquare.getItem())<br>}</code></p>
        </div>
        <h4>In</h4>
        <p>Suppose we had a different Square class that can hold an item and compare it with another item:</p>
        <div class="ln-flex-center">
          <p><code>class Square&lt;in T&gt;(private val item: T) {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun compareValues(otherItem: T): Boolean = item == otherItem<br>}</code></p>
        </div>
        <p>Similar to what we did above, we can assign a <code>Square&lt;Number&gt;</code> to a variable of type <code>Square&lt;Int&gt;</code> because <code>Square&lt;Number&gt;</code> is a subtype of <code>Square&lt;Int&gt;</code> (because of the <code>in</code> modifier):</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>}</code></p>
        </div>
        <p>For the same reason, we can also assign a <code>Square&lt;Number&gt;</code> to a variable of type <code>Square&lt;Double&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleSquare: Square&lt;Double&gt; = numSquare<br>}</code></p>
        </div>
        <p>And <code>Square&lt;Double&gt;</code> can call <code>compareValues()</code> because the subtype (<code>Square&lt;Number&gt;</code>) does accept at least the same argument types that the supertype (<code>Square&lt;Double&gt;</code>) does.</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleSquare: Square&lt;Double&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;println(doubleSquare.compareValues(2.2))<br>}</code></p>
        </div>
      </div>
      <h2 id="abstractdatatypes">Abstract Data Types</h2>
      <p>An abstract data type is a basic (abstract) description of a data structure. It specifies the type of data stored, the operations supported, and the types of parameters of the operations. Most importantly, an ADT specifies what each operation does, but not how the operation does it.</p>
      <p>For example, a list is an abstract data type. We can say that the list holds Ints and that the operations we can perform on a list are to insert into and delete from the list. However, we are not specifying how the values of the list are stored, and we are not specifying how the insert and delete operations are implemented.</p>
      <p>On the other hand, a linked list is a data structure. Each element in the list is a node that contains a value and a pointer to the next node (we're specifying how the values of the list are stored). Insertion and deletion of elements are performed by following each node's next pointer to traverse the linked list until the desired node is reached (we're specifying how the operations are implemented).</p>
      <div class="ln-box">
        <p>The set of behaviors supported by the ADT is referred to as its public interface.</p>
      </div>
      <h2 id="functionaldatastructures">Functional Data Structures</h2>
      <p>Suppose we wanted to design an interface to compute expressions like `(1+2)+4`.</p>
      <div class="ln-flex-center">
        <p><code>interface Expr<br>class Num(val value: Int): Expr<br>class Sum(val left: Expr, val right: Expr): Expr</code></p>
      </div>
      <p>And to use this to represent `(1+2)+4`, it would look like this:</p>
      <div class="ln-flex-center">
        <p><code>Sum(Sum(Num(1), Num(2)), Num(4))</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/expr.png">
      </div>
      <p>To actually evaluate the result of the expression, we can write a function:</p>
      <div class="ln-flex-center">
        <p><code>fun eval(e: Expr): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when(e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Num -> e.value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Sum -> eval(e.right) + eval(e.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -> throw IllegalArgumentException("Unknown expression")<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <p>And to call the function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>We need to have the <code>else</code> part in the <code>when</code> expression because if new subclasses of <code>Expr</code> are created, the <code>when</code> expression needs to know how to handle those.</p>
        <p>However, we may not want other people to create new subclasses of <code>Expr</code> (and typing that <code>else</code> part can be a little annoying). In Kotlin, we can create a sealed class so that only the classes that are compiled with <code>Expr</code> can be subclasses. We do this by adding <code>sealed</code> in front of the class/interface.</p>
        <div class="ln-flex-center">
          <p><code>sealed interface Expr<br>class Num(val value: Int): Expr<br>class Sum(val left: Expr, val right: Expr): Expr<br><br>fun eval(e: Expr): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when(e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Num -> e.value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Sum -> eval(e.right) + eval(e.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
      </div>
      <p>Recall that in functional programming, data is not modified. This means that functional data structures must be immutable. So we can't use arrays, (imperative) linked lists, etc.</p>
      <p>Notice in the <code>Expr</code> example, when evaluating the result of the expression, we never changed any values. We sorta "passed it up the chain".</p>
      <p>In principle, if we want to perform insert or delete operations on functional data structures, we make a new copy based on the inputs but with the desired changes, leaving the inputs unmodified.</p>
      <h3>Singly Linked List</h3>
      <p>Linked lists are a common functional data structure because</p>
      <ul>
        <li>they're persistent</li>
        <li>prepending (producing a new list) is `O(1)`</li>
        <li>building an `n`-element list is `O(n)`</li>
      </ul>
      <div class="ln-box">
        <p>We can see why by comparing it to an array list, both the mutable and immutable versions.</p>
        <p>For the mutable array list:</p>
        <ul>
          <li>prepending is `O(n)` because everything has to be shifted over</li>
          <li>while appending is usually `O(1)`, it can be `O(n)` if the array list is full (we have to create a bigger array list to add the new element)
            <ul>
              <li>in the worst case, it's `O(n^2)` (think about starting with an array list of size `1` and appending)</li>
            </ul>
          </li>
        </ul>
        <p>For the immutable array list:</p>
        <ul>
          <li>a new array has to be created for each insert/delete operation, so building a new list is `O(n)` and doing this for `n` operations makes it `O(n^2)`</li>
        </ul>
      </div>
      <p>Here's how a functional singly linked list could be implemented:</p>
      <div class="ln-flex-center">
        <p><code>sealed class MyList&lt;out A&gt;<br>object MyNil: MyList&lt;Nothing&gt;()<br>data class MyCons&lt;out A&gt;(val head: A, val tail: MyList&lt;A&gt;): MyList&lt;A&gt;()</code></p>
      </div>
      <p>The object and the data class represent the two possibilities that a list can be. The <code>MyNil</code> object represents an empty list and <code>MyCons</code> represents a non-empty list. (Cons is short for "construct".) If there is only one item in the list, the tail is <code>MyNil</code>.</p>
      <div class="ln-box">
        <p>In Kotlin, <code>Nothing</code> is a subtype of every type. So by using the <code>out</code> annotation, <code>MyList&lt;Nothing&gt;</code> is a subtype of lists of any other types.</p>
      </div>
      <p>This is what it looks like to create a list:</p>
      <div class="ln-flex-center">
        <p><code>val l: MyList&lt;Int&gt; = MyCons(1, MyCons(2, MyCons(3, MyNil)))</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/cons.png">
      </div>
      <p>It is a little bit complicated to create lists this way. We can make it easier by creating a function similar to Kotlin's <code>listOf()</code> function.</p>
      <div class="ln-flex-center">
        <p><code>sealed class MyList&lt;out A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;companion object {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun &lt;A&gt; of(vararg aa: A): MyList&lt;A&gt; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val tail = aa.sliceArray(1 until aa.size)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return if (aa.isEmpty()) MyNil else MyCons(aa[0], of(*tail))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val l = MyList.of(1, 4, 22, -30, 1)<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>A companion object is a singleton object whose properties and functions are not tied to an instance of the class. This means that we can call a companion object's functions without having to create an instance of the class first. Basically, think of <code>static</code> in Java.</p>
        <p><code>vararg</code> specifies that the parameter will be an array*, where the number of elements can vary depending on how many arguments are passed. This makes the <code>of()</code> function a variadic function, meaning that it can accept zero or more arguments.</p>
        <p>The <code>*</code> in <code>MyCons(aa[0], of(*tail))</code> is the "spread operator", which passes the contents of an array as an argument to a function.</p>
        <p>*Wait a minute, didn't I say arrays weren't allowed in functional programming? In this case, the array isn't being changed (only consumed) so no data is being modified.</p>
      </div>
      <p>In addition (😏), we can define functions to compute the sum (😏) and product of all the elements in our list.</p>
      <div class="ln-flex-center">
        <p><code>fun sum(ints: MyList&lt;Int&gt;): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (ints) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt; ints.head + sum(ints.tail)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun product(doubles: MyList&lt;Double&gt;): Double =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (doubles) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; 1.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (doubles.head == 0.0) 0.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else doubles.head * product(doubles.tail)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val ints = MyList.of(1, 4, 22, -30, 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(MyList.sum(ints))<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubles = MyList.of(1.0, 4.0, 22.0, -30.0, 1.0)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(MyList.product(doubles))<br>}</code></p>
      </div>
      <h3>Data Sharing</h3>
      <p>Now for the million-dollar question: since <code>MyList</code> is a functional data structure, how do we add and remove elements from <code>MyList</code>?</p>
      <p>Let's say we wanted to add an element to the front of a list. In this case, we return a new list with the element we want to add as the head and the existing list as the tail:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; prepend(l: MyList&lt;A&gt;, e: A): MyList&lt;A&gt; = MyCons(e, l)</code></p>
      </div>
      <p>If we want to remove an element from the front of a list, we return the list's tail:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; premove(l: MyList&lt;A&gt;): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt; l.tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; MyNil<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-box">
        <p>To insert and remove at any index:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; insertAt(l: MyList&lt;A&gt;, index: Int, e: A): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (index == 0) MyCons(e, l)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else MyCons(l.head, insertAt(l.tail, index - 1, e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; MyNil<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; removeAt(l: MyList&lt;A&gt;, index: Int): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (index == 0) l.tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else MyCons(l.head, removeAt(l.tail, index - 1))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; MyNil<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <p>Basically, we recursively traverse the list until we reach the desired index.</p>
      </div>
      <p>A (perhaps) subtle thing to note here is that we're not actually creating new lists and copying over the values from the existing list to the new list; We're reusing the reference to the existing list. This is called data sharing.</p>
      <h2 id="errorhandling">Error Handling</h2>
      <div class="ln-box">
        <p>A quick note about semantics. An error is a problem that is caused by something out of the application's control. Examples are out-of-memory errors and stack overflows. An exception is an event that an application can catch. These are the errors from try/catch blocks.</p>
        <p>This section is really going over "exceptions", not "errors". But I'll use them interchangeably.</p>
      </div>
      <p>As mentioned in the "Side Effects" section, throwing an exception is not functional programming. This is because throwing an exception interrupts the normal flow of the program, so now whatever was in charge of running the application has to change what it was expecting (normal execution) and deal with it.</p>
      <h3>Exceptions Break Referential Transparency</h3>
      <p>Recall that referential transparency is the ability to replace an expression with a constant value if the expression will always evaluate to the same value.</p>
      <p>Throwing exceptions break referential transparency. Consider this function:</p>
      <div class="ln-flex-center">
        <p><code>fun idkWhatThisDoes(): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;val y: Int = throw Exception("boom")<br>&nbsp;&nbsp;&nbsp;&nbsp;return try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val x = 42 + 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x + y<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e: Exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <p>If we call this function, we will get an error message at runtime: 'Exception in thread "main" java.lang.Exception: boom'.</p>
      <p>If this function was referentially transparent, we should be able to replace <code>y</code> with its value without changing the result of the function call.</p>
      <div class="ln-flex-center">
        <p><code>fun idkWhatThisDoes(): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;return try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val x = 42 + 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x + (throw Exception("boom")) as Int<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (e: Exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <p>However, if we call this function, the exception will be caught and `43` will be printed out.</p>
      <div class="ln-box">
        <p>The meaning/value of a referentially transparent expression does not depend on context and can be reasoned about locally. While the meaning/value of a non-referentially transparent expression is context dependent and needs more global reasoning.</p>
        <p>For example, the meaning of the expression <code>throw Exception("boom")</code> takes on different meanings depending on which <code>try</code> block it's nested inside.</p>
      </div>
      <div class="ln-box">
        <p>Note that this does not mean that try/catch blocks cannot be used in functional programming. We can still use try/catch blocks; We just can't throw exceptions.</p>
      </div>
      <h3>Dealing with Exceptions</h3>
      <p>Exceptions can't be avoided, but if they can't be thrown, then how do we deal with them?</p>
      <p>Consider this function where we might want to handle the exception of dividing by `0`:</p>
      <div class="ln-flex-center">
        <p><code>fun mean(xs: List&lt;Double&gt;): Double =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) throw ArithmeticException("cannot get mean of empty list")<br>&nbsp;&nbsp;&nbsp;&nbsp;else xs.sum() / xs.size</code></p>
      </div>
      <div class="ln-box">
        <p>This mean function is a partial function. That is, it doesn't always produce an output for any input values. In this case, it doesn't return a value for an empty list.</p>
      </div>
      <h4>Approach 1: Sentinel Value</h4>
      <p>Instead of throwing the exception, we can return some dummy value, like null, `-1`, or <code>Double.NaN</code>.</p>
      <div class="ln-flex-center">
        <p><code>fun mean(xs: List&lt;Double&gt;): Double =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) Double.NaN<br>&nbsp;&nbsp;&nbsp;&nbsp;else xs.sum() / xs.size</code></p>
      </div>
      <h4>Drawbacks of Using a Sentinel Value</h4>
      <p>The caller may forget to check if the sentinel value was returned and treat it as a normal value, resulting in logic errors.</p>
      <p>If using polymorphic code, there may not be a sentinel value of the correct type for certain output types. For example, if the function is taking in a list of <code>A</code>s, we can't invent a value of type <code>A</code>.</p>
      <h4>Approach 2: Supplied Default Value</h4>
      <p>Instead of us deciding what to return, we can pass the decision over to the caller.</p>
      <div class="ln-flex-center">
        <p><code>fun mean(xs: List&lt;Double&gt;, onEmpty: Double): Double =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) onEmpty<br>&nbsp;&nbsp;&nbsp;&nbsp;else xs.sum() / xs.size</code></p>
      </div>
      <h4>Approach 3: New Classes (Preferred Approach)</h4>
      <p>Instead of returning predefined values, we can create our own values to represent errors (and successes).</p>
      <h5>Option</h5>
      <div class="ln-flex-center">
        <p><code>sealed class Option&lt;out A&gt;<br>data class Some&lt;out A&gt;(val get: A): Option&lt;A&gt;()<br>object None: Option&lt;Nothing&gt;()</code></p>
      </div>
      <p>When a function is defined for an input, a <code>Some</code> object is returned. When a function is undefined for an input, the <code>None</code> object is returned.</p>
      <p>Applying this to our mean function:</p>
      <div class="ln-flex-center">
        <p><code>fun mean(xs: List&lt;Double&gt;): Option&lt;Double&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) None<br>&nbsp;&nbsp;&nbsp;&nbsp;else Some(xs.sum() / xs.size)</code></p>
      </div>
      <h5>Drawbacks of Using Option</h5>
      <p>An <code>Option</code> doesn't tell us anything about what went wrong or why the error occurred.</p>
      <h5>Either</h5>
      <div class="ln-flex-center">
        <p><code>sealed class Either&lt;out E, out A&gt;<br>data class Left&lt;out E&gt;(val value: E): Either&lt;E, Nothing&gt;()<br>data class Right&lt;out A&gt;(val value: A): Either&lt;Nothing, A&gt;()</code></p>
      </div>
      <p>For successful function calls, we return a <code>Right</code> object (because it's right!). For errors, we return a <code>Left</code> object (because it's not right!).</p>
      <p>The <code>Either</code> data type has two values. The left (type <code>E</code>) is the value representing an error and the right (type <code>A</code>) is the value representing the result of a function.</p>
      <p>Applying this to our mean function:</p>
      <div class="ln-flex-center">
        <p><code>fun mean(xs: List&lt;Double&gt;): Either&lt;String, Double&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) Left("cannot get mean of empty list")<br>&nbsp;&nbsp;&nbsp;&nbsp;else Right(xs.sum() / xs.size)</code></p>
      </div>
      <h2 id="strictnessnlaziness">Strictness and Laziness</h2>
      <p>Strict evaluation means that expressions are evaluated and bound to variables when they are defined. Lazy evaluation means that expressions are evaluated only when they are used. Note that this means a variable can be assigned an expression, but that expression may not necessarily be evaluated. I promise this makes more sense with examples.</p>
      <p>Stepping away from Kotlin for just a second, consider this line of code in some language:</p>
      <div class="ln-flex-center">
        <p><code>print length([2+1, 3*2, 1/0, 5-4])</code></p>
      </div>
      <p>Under strict evaluation, this results in an error because the <code>1/0</code> part will be evaluated right away. But under lazy evaluation, this line of code will print `4` since the values of the elements in the list aren't needed for the <code>length()</code> function.</p>
      <p>In fact, we're more familiar with lazy evaluation than we might think. The short-circuiting logic in the <code>&&</code> and <code>||</code> operators are examples of lazy evaluation.</p>
      <div class="ln-flex-center">
        <p><code>if(3 == 4 && a &lt; b)  // a &lt; b is not evaluated<br>if(3 == 3 || a &lt; b) // a &lt; b is not evaluated</code></p>
      </div>
      <div class="ln-box">
        <p>As we can see above, the <code>if</code> control construct can be non-strict.</p>
        <p>The <code>if/else</code> statement is a little more interesting. The <code>if</code> part is strict since it will always evaluate the condition to know which branch to take. But as a whole, the two branches are non-strict since only one branch will ever be evaluated.</p>
      </div>
      <h3>Lazy Behavior With Functions</h3>
      <p>Functions can be non-strict where they accept arguments without evaluating them. This is done by having the functions take functions (rather than values) as arguments and calling the functions only when needed.</p>
      <p>This is an example of a non-strict function:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; lazyIf(cond: Boolean, onTrue: () -&gt; A, onFalse: () -&gt; A): A =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (cond) onTrue() else onFalse()</code></p>
      </div>
      <p>To verify that this is actually a non-strict function, we can take advantage of print statements:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;var a = 21<br>&nbsp;&nbsp;&nbsp;&nbsp;val y = lazyIf((a &lt; 22), { println("a") }, { println("b") })<br>&nbsp;&nbsp;&nbsp;&nbsp;a = 22<br>&nbsp;&nbsp;&nbsp;&nbsp;val z = lazyIf((a &lt; 22), { println("a") }, { println("b") })<br>}</code></p>
      </div>
      <p>What is printed is <code>a</code> and <code>b</code> (each only once). If this wasn't a non-strict function, then each of <code>a</code> and <code>b</code> would've been printed twice since the arguments would have been evaluated right away.</p>
      <div class="ln-box">
        <p>The unevaluated form of an expression is called a "thunk". More precisely, a thunk is a function wrapper around the expression we want to delay the evaluation of.</p>
      </div>
      <h3>Lazy Behavior With Ranges</h3>
      <p>Consider this code:</p>
      <div class="ln-flex-center">
        <p><code>val r: LongRange = 1..1000000000000</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;println(r)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(r.take(5))<br>&nbsp;&nbsp;&nbsp;&nbsp;println(r.take(5000000))<br>}</code></p>
      </div>
      <p>The output of the first <code>println()</code> is `1...1000000000000`. The output of the second <code>println()</code> is `[1, 2, 3, 4, 5]`. But the third <code>println()</code> fails because there should not be enough memory to store `5,000,000` numbers.</p>
      <p>Notice that there was not enough memory for `5,000,000` numbers, but running <code>val r: LongRange = 1..1000000000000</code> was fine. This shows that the range isn't evaluated right away; only when it's used.</p>
      <h3>Lazy Initialization in Kotlin</h3>
      <p>Lazy initialization is the tactic of delaying the creation of an object, calculation of a value, or execution of an expensive process until the first time it is needed. Kotlin has a built-in function called <code>lazy</code> to accomplish this.</p>
      <p>First, we'll look at greedy initialization.</p>
      <div class="ln-flex-center">
        <p><code>fun maybeTwice(b: Boolean, i: () -&gt; Int) = if (b) i() + i() else 0</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val x = maybeTwice(true, { println("hi"); 1 + 41 })<br>}</code></p>
      </div>
      <p>Here, we're passing in a function that prints "hi" and evaluates to `42`. <code>maybeTwice()</code> takes in that function and calls it twice, which means that "hi" will be printed twice.</p>
      <p>Calling the function twice should result in the same thing. So why should we spend time running the function a second time if we already know its value? This is where <code>lazy</code> comes in.</p>
      <div class="ln-flex-center">
        <p><code>fun maybeTwiceLazy(b: Boolean, i: () -&gt; Int) {<br>&nbsp;&nbsp;&nbsp;&nbsp;val j: Int by lazy(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;if (b) j + j else 0<br>}</code></p>
      </div>
      <p>The first time <code>j</code> is referenced, it calls the function <code>i()</code>. The value of <code>j</code> is then cached so that when <code>j</code> is called the second time, it refers to the cached value instead of running <code>i()</code> again. And we can verify this with the same <code>main()</code> code above to see that "hi" is printed only once.</p>
      <h3>Lazy Lists</h3>
      <p>From here, we'll continue by looking at a problem and building up the pieces towards a solution.</p>
      <p>Consider this line of code:</p>
      <div class="ln-flex-center">
        <p><code>listOf(1, 2, 3, 4).map{ it + 10 }.filter{ it % 2 == 0 }.map{ it * 3 }</code></p>
      </div>
      <p>We start with a list of `[1,2,3,4]`, add `10` to each number, get only the even numbers, and multiply those even numbers by `3`. Under the hood, multiple lists are being created at each step.</p>
      <ol>
        <li><code>map{ it + 10 }</code> creates an intermediate list (`[11,12,13,14]`)</code></li>
        <li><code>filter{ it % 2 == 0 }</code> creates an intermediate list (`[12,14]`)</code></li>
        <li><code>map{ it * 3 }</code> creates the final list (`[36,42]`)</code></li>
      </ol>
      <p>The problem with this is that it's inefficient to create intermediate lists that are used only as inputs to the next step and never used again. We can run into memory issues if the intermediate lists are very large.</p>
      <p>We can avoid this problem of creating temporary data structures by using laziness to combine sequences of transformations into a single pass.</p>
      <div class="ln-box">
        <p>Imagine that we had a deck of cards and we were asked (by a magician I guess) to remove all the odd-numbered cards and then flip over all the queens. Naturally, we'd go through the deck one card at a time and check if the current card is odd or a queen. That way, we'd only need to go through the deck once.</p>
        <p>It would be inefficient to go through the deck and pick out all the odd numbers first, then go through what's left of the deck and flip over all the queens. This is what's happening with the code above.</p>
      </div>
      <h3>Stream</h3>
      <p>We'll create a <code>Stream</code> to store the elements in a way that is convenient to perform transformations on them.</p>
      <div class="ln-flex-center">
        <p><code>sealed class Stream&lt;out A&gt;<br>data class Cons&lt;out A&gt; (<br>&nbsp;&nbsp;&nbsp;&nbsp;val head: () -&gt; A,<br>&nbsp;&nbsp;&nbsp;&nbsp;val tail: () -&gt; Stream&lt;A&gt;<br>): Stream&lt;A&gt;()<br>object Empty: Stream&lt;Nothing&gt;()</code></p>
      </div>
      <div class="ln-box">
        <p>This is very similar to the implemention of a singly linked list (see the "Singly Linked List" section). The only difference is that the <code>Cons</code> in <code>MyList</code> takes input parameters that are already evaluated, while the <code>Cons</code> in <code>Stream</code> takes input parameters that are thunks instead of strict values.</p>
      </div>
      <p>Since the head is a function, we need a way to evaluate the function when we need its value. We'll do this with an extension function called <code>headOption()</code>:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; Stream&lt;A&gt;.headOption(): Option&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Empty -&gt; None<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt; Some(head())<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-box">
        <p>Recall that back in the "Dealing with Exceptions" section, we created an <code>Option</code> class to represent errors and successes. Here is the implementation again:</p>
        <div class="ln-flex-center">
          <p><code>sealed class Option&lt;out A&gt;<br>data class Some&lt;out A&gt;(val get: A): Option&lt;A&gt;()<br>object None: Option&lt;Nothing&gt;()</code></p>
        </div>
        <p>Here, we'll add an extension function called <code>getOrElse()</code> that tries to get the value of an <code>Option</code>, or the user-provided default value if there is no value.</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; Option&lt;A&gt;.getOrElse(default: () -&gt; A): A =<br>&nbsp;&nbsp;&nbsp;&nbsp;when(this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Some -&gt; this.get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is None -&gt; default()<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <p>We're using an <code>Option</code> to handle the case of returning the head of an empty list.</p>
      </div>
      <p>And we'll need a way to create a <code>Stream</code> with elements:</p>
      <div class="ln-flex-center">
        <p><code>sealed class Stream&lt;out A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;companion object {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun &lt;A&gt; of(vararg xs: A): Stream&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (xs.isEmpty()) empty()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else cons({ xs[0] }, { of(*xs.sliceArray(1 until xs.size)) })<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun &lt;A&gt; empty(): Stream&lt;A&gt; = Empty<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun &lt;A&gt; cons(hd: () -&gt; A, tl: () -&gt; Stream&lt;A&gt;): Stream&lt;A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val head: A by lazy(hd)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val tail: Stream&lt;A&gt; by lazy(tl)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Cons({ head }, { tail })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <div class="ln-box">
        <p><code>{ xs[0] }</code> is shorthand for creating a function that takes no arguments and returns <code>xs[0]</code>.</p>
      </div>
      <p>Here's an example of creating a <code>Stream</code>:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val s1 = Empty<br>&nbsp;&nbsp;&nbsp;&nbsp;println(s1)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(s1.headOption().getOrElse({"No Value Found"}))<br>&nbsp;&nbsp;&nbsp;&nbsp;val s2 = Stream.of(1, 2, 3, 4, 5)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(s2)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(s2.headOption().getOrElse({"No Value Found"}))<br>}</code></p>
      </div>
      <p>(Note: this won't work in the Kotlin playground.) And this is the output:</p>
      <div class="ln-flex-center">
        <p><code>Empty@12edcd21<br>No Value Found<br>Cons(head=Function0&lt;A&gt;, tail=Function0&lt;Stream&lt;? extends A&gt;&gt;)<br>1</code></p>
      </div>
      <div class="ln-box">
        <p>We can write a function to check if an element exists in a <code>Stream</code>.</p>
        <div class="ln-flex-center">
          <p><code>fun exists(p: (A) -&gt; Boolean): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt; p(this.head()) || this.tail().exists(p)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; false<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val x = Stream.of("a", "b", "c", "d")<br>&nbsp;&nbsp;&nbsp;&nbsp;println(x.exists{ it == "a" })<br>&nbsp;&nbsp;&nbsp;&nbsp;println(x.exists{ it == "e" })<br>}</code></p>
        </div>
        <p>One thing to note here is that if the function being passed to <code>exists()</code> returns true for an element, then any elements after it are never evaluated. #laziness</p>
      </div>
      <div class="ln-box">
        <p>Kotlin's <code>fold()</code> function takes in two parameters: 1) an initial value for an accumulator and 2) a function that is applied to each element in the list.</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val x = listOf(1, 2, 3, 4, 5)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(x.fold(0, {acc: Int, i: Int -&gt; acc + i }))<br>}</code></p>
        </div>
      </div>
      <p>Now this is where everything starts to come together. Recall that the problem we were trying to solve was to not create intermediate lists for code like this:</p>
      <div class="ln-flex-center">
        <p><code>listOf(1, 2, 3, 4).map{ it + 10 }.filter{ it % 2 == 0 }.map{ it * 3 }</code></p>
      </div>
      <p>Referring back to the card analogy, what we would like to do is to look at the list one element at a time, perform all those transformations on that element, and add the result to the final list. We can do this by building off of the idea behind Kotlin's <code>fold()</code> function.</p>
      <p>We'll need a custom fold-like function that works with our <code>Stream</code>.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;B&gt; foldRight(z: () -&gt; B, f: (A, () -&gt B) -&gt; B): B =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (this) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt; f(this.head()) { this.tail().foldRight(z, f) }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Empty -&gt; z()<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-box">
        <p>There is another generic parameter <code>B</code> so that the return type does not need to be the same as the type of the items in the <code>Stream</code>.</p>
      </div>
      <p><code>z()</code> acts as the accumulator and <code>f()</code> is the function that is applied to each element in the <code>Stream</code>.</p>
      <div class="ln-box">
        <p>Here's an example of using <code>foldRight()</code> to find the sum of a <code>Stream</code> of Ints:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val z: Stream&lt;Int&gt; = Stream.of(1, 2, 3, 2, 4, 6)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(z.foldRight({ 0 }, { a, b -&gt; a + b() }))<br>}</code></p>
        </div>
        <p>Here's an example of using <code>foldRight()</code> to implement an exists function:</p>
        <div class="ln-flex-center">
          <p><code>fun existsUsingFoldRight(p: (A) -&gt; Boolean): Boolean =<br>&nbsp;&nbsp;&nbsp;&nbsp;foldRight({ false }, { a, b -&gt; p(a) || b() })</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val x = Stream.of(1, 2, 3, 4, 5)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(x.existsUsingFoldRight{ it == 3 })<br>}</code></p>
        </div>
      </div>
      <p>Now, instead of using Kotlin's <code>filter()</code> and <code>map()</code>, we can use <code>foldRight()</code> to write our own versions of filter and map that work with our <code>Stream</code>.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A, B&gt; Stream&lt;A&gt;.map(f: (A) -&gt; B): Stream&lt;B&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;this.foldRight(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Stream.empty&lt;B&gt;() },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ h, t -&gt; Stream.cons({ f(h) }, t) }<br>&nbsp;&nbsp;&nbsp;&nbsp;)</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; Stream&lt;A&gt;.filter(f: (A) -&gt; Boolean): Stream&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;this.foldRight(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Stream.empty&lt;A&gt;() },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ h, t -&gt; if (f(h)) Stream.cons({ h }, t) else t() }<br>&nbsp;&nbsp;&nbsp;&nbsp;)</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="">
      </div>
      <div class="ln-box">
        <p>To make a <code>Stream</code> easier to see, we'll create a function that converts a <code>Stream</code> to a list:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; examineStream(s: Stream&lt;A&gt;): List&lt;A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(s: Stream&lt;A&gt;, acc: List&lt;A&gt;): List&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when (s) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Empty -&gt; acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt; helper(s.tail(), acc + listOf(s.head()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return helper(s, emptyList&lt;A&gt;())<br>}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val x = Stream.of(1, 2, 3, 4, 5)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(examineStream(x.map{ it + 3 }))<br>&nbsp;&nbsp;&nbsp;&nbsp;println(examineStream(x.filter{ it &gt; 3 }))<br>}</code></p>
        </div>
      </div>
      <p>With these versions of filter and map, we have now solved the problem of creating temporary lists! Let's look at the steps involved for</p>
      <div class="ln-flex-center">
        <p><code>Stream.of(1, 2, 3, 4).map{ it + 10 }.filter{ it % 2 == 0 }.map{ it * 3 }</code></p>
      </div>
      <ol>
        <li><code>Stream.of(1, 2, 3, 4).map{ it + 10 }.filter{ it % 2 == 0 }.map{ it * 3 }</code></li>
        <li><code>Cons({ 11 }, { Stream.of(2, 3, 4).map{ it + 10 } }).filter{ it % 2 == 0 }.map{ it * 3 }</code></li>
        <li><code>Stream.of(2, 3, 4).map{ it + 10 }.filter{ it % 2 == 0 }.map{ it * 3 }</code></li>
        <li><code>Cons({ 12 }, { Stream.of(3, 4).map{ it + 10 } }).filter{ it % 2 == 0 }.map{ it * 3 }</code></li>
        <li><code>Cons({ 12 }, { Stream.of(3, 4).map{ it + 10 }.filter{ it % 2 == 0} }).map{ it * 3 }</code></li>
        <li><code>Cons({ 36 }, { Stream.of(3, 4).map{ it + 10 }.filter{ it % 2 == 0}.map{ it * 3 } })</code></li>
      </ol>
      <p>This is what (I believe) it actually looks like at the end. We only applied all the transformations on the first element, and if it didn't make it through all of them, then we moved on to the next element until that element completed all the transformations. The transformations aren't applied to the rest of the elements until they need to be (e.g., when <code>examineStream()</code> is calling <code>s.tail()</code>).</p>
      <h2 id="corecursion">Corecursion</h2>
      <p>Corecursion is kinda the opposite of recursion in a way. It uses recursion to generate data instead of, well, whatever you decide to use recursion for. It may seem weird, but there's no base case or termination condition in corecursion. This allows us to create infinite data structures that aren't actually infinite.</p>
      <div class="ln-flex-center">
        <p><code>fun ones(): Stream&lt;Int&gt; = Stream.cons({ 1 }, { ones() })</code></p>
      </div>
      <div class="ln-box">
        <p>We can define a function to take `n` elements from an infinite <code>Stream</code>.</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; Stream&lt;A&gt;.take(n: Int): Stream&lt;A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun helper(xs: Stream&lt;A&gt;, n: Int): Stream&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when(xs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Empty -&gt; Stream.empty()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n == 0) Stream.empty()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else Stream.cons(xs.head, { helper(xs.tail(), n-1) })<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return helper(this, n)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;println(examineStream(ones().take(100)))<br>}</code></p>
        </div>
      </div>
      <p>We can have something a little more useful than an infinite <code>Stream</code> of just `1`s.</p>
      <div class="ln-flex-center">
        <p><code>fun countUp(n: Int): Stream&lt;Int&gt; = Stream.cons({ n }, { countUp(n+1) })</code></p>
      </div>
      <h2 id="memoization">Memoization</h2>
      <p>Let's look at the classic example of calculating the Fibonacci numbers.</p>
      <div class="ln-box">
        <p>The Fibonacci numbers are defined by:</p>
        <div class="ln-center">
          <p>`F_0=0`, `F_1=1`</p>
          <p>`F_n=F_(n-1)+F_(n-2)`</p>
        </div>
        <p>The first `11` Fibonacci numbers are:</p>
        <table class="table table-bordered ln-center">
          <tr>
            <td>`F_0`</td>
            <td>`F_1`</td>
            <td>`F_2`</td>
            <td>`F_3`</td>
            <td>`F_4`</td>
            <td>`F_5`</td>
            <td>`F_6`</td>
            <td>`F_7`</td>
            <td>`F_8`</td>
            <td>`F_9`</td>
            <td>`F_10`</td>
          </tr>
          <tr>
            <td>`0`</td>
            <td>`1`</td>
            <td>`1`</td>
            <td>`2`</td>
            <td>`3`</td>
            <td>`5`</td>
            <td>`8`</td>
            <td>`13`</td>
            <td>`21`</td>
            <td>`34`</td>
            <td>`55`</td>
          </tr>
        </table>
      </div>
      <p>If we were to do this in code, it would look like this:</p>
      <div class="ln-flex-center">
        <p><code>fun naiveFibs(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt; 0) -1<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (n == 0) 0<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (n == 1) 1<br>&nbsp;&nbsp;&nbsp;&nbsp;else naiveFibs(n-2) + naiveFibs(n-1)</code></p>
      </div>
      <p>As can be inferrred from the name, this way of calculating the Fibonacci numbers is very inefficient. Consider the example of calculating the `5^(th)` Fibonacci number.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/fibonacci.png">
      </div>
      <p>Look at how many of the calculations are repeated. Not only is it wasteful, it's actually time-consuming. Instead of recalculating the same values for which we already the answer, we can store them so that we can reuse them when we need to — this is memoization! We actually saw this in action in the "Lazy Initialization in Kotlin" section with Kotlin's <code>lazy</code> function.</p>
      <p>We'll use our <code>Stream</code> to generate an infinite sequence of Fibonacci numbers.</p>
      <div class="ln-box">
        <p>While <code>Cons</code> objects (in a <code>Stream</code>) are evaluated only when forced, there's still a problem in that they are evaluated as many times as they are forced. Suppose we had some time-consuming function called <code>expensive()</code>.</p>
        <div class="ln-flex-center">
          <p><code>val x = Cons({ expensive(y) }, { tl })<br>val h1 = x.headOption()<br>val h2 = x.headOption()</code></p>
        </div>
        <p><code>expensive(y)</code> will be evaluated multiple times. To solve this, we'll use memoization to cache the value of a <code>Cons</code> once they are forced.</p>
      </div>
      <p>To utilize laziness, we'll define a smart constructor, which is a function for constructing a data type that has a slightly different signature than the real constructor.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; cons(hd: () -&gt; A, tl: () -&gt; Stream&lt;A&gt;): Stream&lt;A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;val head: A by lazy(hd)<br>&nbsp;&nbsp;&nbsp;&nbsp;val tail: Stream&lt;A&gt; by lazy(tl)<br>&nbsp;&nbsp;&nbsp;&nbsp;return Cons({ head }, { tail })<br>}</code></p>
      </div>
      <p>This ensures that the thunk will only be called once when forced for the first time. Subsequent forces will return the cached values from using <code>lazy</code>.</p>
      <div class="ln-box">
        <p>By convention, smart constructors are in the companion object of the base class. Their names are also the lowercase version of the corresponding data structure.</p>
      </div>
      <p>So this is how we would generate Fibonacci numbers without recalculating old Fibonacci numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun fibsInfinity(): Stream&lt;Int&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun helper(curr: Int, nxt: Int): Stream&lt;Int&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream.cons({ curr }, { helper(nxt, curr + nxt) })<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0, 1)<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>To get the `n^(th)` Fibonacci number, we can drop the first `n-1` elements of the <code>Stream</code>. We'll need a drop function for this:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; Stream&lt;A&gt;.drop(n: Int): Stream&lt;A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(xs: Stream&lt;A&gt;, n: Int): Stream&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when (xs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Empty -&gt; Stream.empty()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Cons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n == 0) xs<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(xs.tail(), n-1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(this, n)<br>}</code></p>
        </div>
      </div>
      <p>So here's the improved version of calculating Fibonacci numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun lazyFibs(n: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;val f = fibsInfinity().drop(n)<br>&nbsp;&nbsp;&nbsp;&nbsp;if (f is Cons) return f.head()<br>&nbsp;&nbsp;&nbsp;&nbsp;else return -1<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>The <code>naiveFibs()</code> function we defined earlier is `O(2^n)` while this <code>lazyFibs()</code> is `O(n)`.</p>
      </div>
      <h2 id="functionalstate">Functional State</h2>
      <p>Program state refers to the values of the variables, data structures, and other information (e.g., the address of next line to execute, the status of I/O operations) that describe the current state of the program at a specific point in time. In functional programming, changes to program state are undesirable.</p>
      <p>So to manipulate program state in a functional way, we view the program state as a transition or action that can be passed around. This keeps the state contained and localized.</p>
      <h3>Generating Random Numbers</h3>
      <p>We'll look at how to pass around state by looking at random number generation.</p>
      <div class="ln-box">
        <p>In programming, it's not really possible to generate numbers that are completely random. This is because deterministic algorithms are used to generate them. And these algorithms typically rely on an initial value, called a "seed". With this seed value, the entire "random" sequence of numbers can be reproduced.</p>
        <p>For example, a fairly simple algorithm to generate pseudorandom numbers could look like this:</p>
        <ol>
          <li>Start with a seed</li>
          <li>Multiply the seed by a constant</li>
          <li>Add another constant</li>
          <li>Take the result modulo the upper bound
            <ul>
              <li>the upper bound is the highest possible number that we want to generate</li>
            </ul>
          </li>
          <li>Take the result and use it as the new seed</li>
          <li>Repeat steps `2-4` to generate a sequence of numbers</li>
        </ol>
        <p>So this section is really looking at generating pseudorandom numbers with a pseudorandom number generator (PNRG).</p>
      </div>
      <p>If we wanted to generate random numbers in Kotlin, we would do something like this:</p>
      <div class="ln-flex-center">
        <p><code>val rng = kotlin.random.Random<br>println(rng.nextInt(10))<br>println(rng.nextInt(10))<br>println(rng.nextInt(10))</code></p>
      </div>
      <p>As we expect, `3` numbers will be printed. Also as we expect, if we run these lines again, then `3` potentially different numbers will be generated. Since calling the same function with the same inputs produces different outputs, <code>nextInt()</code> is not referentially transparent. While we don't know exactly how <code>nextInt()</code> is implemented, we can see that there is some sort of state mutation happening.</p>
      <div class="ln-box">
        <p>Why does this matter? Let's say we're writing a function that simulates the rolling of a six-sided die, i.e., the function should return a value between `1` and `6`, inclusive.</p>
        <div class="ln-flex-center">
          <p><code>fun rollDie(): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;val rng = kotlin.random.Random<br>&nbsp;&nbsp;&nbsp;&nbsp;return rng.nextInt(6)<br>}</code></p>
        </div>
        <p>There is an off-by-one error since <code>nextInt(6)</code> returns a number between `0` and `5`, inclusive. However, if we test this function, then `5` out of `6` times, it will look like it's working as intended.</p>
      </div>
      <p>Let's see how we can generate random numbers in a functional manner.</p>
      <div class="ln-flex-center">
        <p><code>interface RNG {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun nextInt(): Pair&lt;Int, RNG&gt;<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>data class SimpleRNG(val seed: Long): RNG {<br>&nbsp;&nbsp;&nbsp;&nbsp;override fun nextInt(): Pair&lt;Int, RNG&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val newSeed = (seed * 0x5DEECE66DL + 0xBL) and 0xFFFFFFFFFFFFL<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val nextRNG = SimpleRNG(newSeed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val n = (newSeed ushr 16).toInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return n to nextRNG<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <div class="ln-box">
        <p><code>ushr</code> is a bitwise shift operator.</p>
        <p><code>to</code> is used to create a <code>Pair</code>. So <code>n to nextRNG</code> is equivalent to <code>Pair(n, nextRNG)</code>.</p>
      </div>
      <p>Forget about the details of the algorithm. The important thing to note is that our new <code>nextInt()</code> function is returning two things here: a random number and a random number generator.</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val rng1: RNG = SimpleRNG(1001)<br>&nbsp;&nbsp;&nbsp;&nbsp;val (n1, rng2) = rng1.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;println(n1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val (n2, rng3) = rng2.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;println(n2)<br>&nbsp;&nbsp;&nbsp;&nbsp;val (n3, rng4) = rng2.nextInt() // rng2 is intentional<br>&nbsp;&nbsp;&nbsp;&nbsp;println(n3)<br>}</code></p>
      </div>
      <p>If we run these lines multiple times, we'll get the same `3` numbers every time.</p>
      <p>So what exactly did we do to make this possible? We made the state change explicity known by asking for a seed and returning the new state instead of implicitly mutating the original state.</p>
      <h3>Stateful APIs</h3>
      <p>Stateful APIs are interfaces in which the next state depends on the previous state. (Here, stateful means that we're creating a new state and using that to do stuff.) Our <code>RNG</code> is an example of a stateful API, and we'll look at how to extend it.</p>
      <p>Let's say we wanted to write a function that generates a pair of random numbers using <code>nextInt()</code>.</p>
      <div class="ln-flex-center">
        <p><code>fun randomPair(rng: RNG): Pair&lt;Pair&lt;Int, Int&gt;, RNG&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;val (i1, rng2) = rng.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;val (i2, rng3) = rng2.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;return (i1 to i2) to rng3<br>}</code></p>
      </div>
      <p>By returning <code>rng3</code>, we're allowing the caller to generate more random numbers if they need to.</p>
      <div class="ln-box">
        <p>Write a function that uses <code>RNG.nextInt()</code> to generate a random integer between `0` and <code>Int.MAX_VALUE</code> (inclusive). Each negative value must be mapped to a distinct nonnegative value. Make sure to handle the corner case when <code>nextInt()</code> returns <code>Int.MIN_VALUE</code>, which doesn't have a nonnegative counterpart. (The range of an integer is `-2,147,483,648` to `2,147,483,647`, inclusive.)</p>
        <div class="collapse ln-box" id="functional_rng_q1">
          <div class="ln-flex-center">
            <p><code>fun nonNegativeInt(rng: RNG): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;val (i1, rng2) = rng.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;return if (i1 &lt; 0) -(i1 + 1) else i1<br>}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#functional_rng_q1" aria-expanded="false" aria-controls="functional_rng_q1">Answer</button>
        <p>Write a new version of the function that returns a <code>Pair&lt;Int, RNG&gt;</code> with the new <code>RNG</code> created when you used the old <code>RNG</code>.</p>
        <div class="collapse ln-box" id="functional_rng_q2">
          <div class="ln-flex-center">
            <p><code>fun nonNegativeInt(rng: RNG): Pair&lt;Int, RNG&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;val (i1, rng2) = rng.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;return (if (i1 &lt; 0) -(i1 + 1) else i1) to rng2<br>}</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#functional_rng_q2" aria-expanded="false" aria-controls="functional_rng_q2">Answer</button>
      </div>
      <div class="ln-box">
        <p>Write a function that takes an <code>Int</code> count and an <code>RNG</code> and generates a <code>List</code> of random <code>Int</code>s in a <code>Pair</code> with the <code>RNG</code> created when the last random <code>Int</code> was generated.</p>
        <div class="collapse ln-box" id="functional_rng_q3">
          <div class="ln-flex-center">
            <p><code>fun ints(count: Int, rng: RNG): Pair&lt;List&lt;Int&gt;, RNG&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (count &gt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val (i, r1) = rng.nextInt()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val (xs, r2) = ints(count-1, r1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listOf(i) + xs to r2<br>&nbsp;&nbsp;&nbsp;&nbsp;} else emptyList&lt;Int&gt;() to rng</code></p>
          </div>
        </div>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#functional_rng_q3" aria-expanded="false" aria-controls="functional_rng_q3">Answer</button>
      </div>
      <p>There's a common pattern (which can be seen in the exercises above) where functions that need to return a value and a state return them as a <code>Pair</code>. These functions have a type of the form <code>(RNG) -&gt; Pair&lt;A, RNG&gt;</code> for some type <code>A</code>. Functions of this type are called "state actions" or "state transitions" because they transform states from one call to the next.</p>
      <div class="ln-box">
        <p><code>(RNG) -&gt; Pair&lt;A, RNG&gt;</code> can be a bit cumbersome to read and type. In Kotlin, we can declare a type alias to make it simpler:</p>
        <div class="ln-flex-center">
          <p><code>typealias Rand&lt;A&gt; = (RNG) -&gt; Pair&lt;A, RNG&gt;</code></p>
        </div>
        <p>Here's an example of how it would be used:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val rng = SimpleRNG(92422)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intR: Rand&lt;Int&gt; = { r -&gt; r.nextInt() }<br>&nbsp;&nbsp;&nbsp;&nbsp;val (n, rng2) = intR(rng)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(n)<br>}</code></p>
        </div>
      </div>
      <h3>Combinators</h3>
      <p>State actions can be combined using combinators, which are higher-order functions that combine or transform functions in some way to produce new functions.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A, B&gt; map(s: Rand&lt;A&gt;, f: (A) -&gt; B): Rand&lt;B&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;{ rng -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val (a, rng2) = s(rng)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(a) to rng2<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <p><code>map</code> is a combinator that takes an <code>RNG</code> function (passed in as <code>s</code>) and applies <code>f</code> to the random number that is generated by <code>s</code>. Here's an example using it:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val rng = SimpleRNG(942)<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleR: Rand&lt;Double&gt; = map(::nonNegativeInt) { i -&gt; i / (Int.MAX_VALUE.toDouble() + 1) }<br>&nbsp;&nbsp;&nbsp;&nbsp;val (d, _) = doubleR(rng)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(d)<br>}</code></p>
      </div>
      <p>So we're taking the random integer generated by <code>nonNegativeInt</code> and dividing it by <code>(Int.MAX_VALUE.toDouble() + 1)</code>.</p>
      <p>Now here's something that's a little more complicated. We can take two state actions and apply a binary function to them:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A, B, C&gt; map2(ra: Rand&lt;A&gt;, rb: Rand&lt;B&gt;, f: (A, B) -&gt; C): Rand&lt;C&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;{ r1: RNG -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val (a, r2) = ra(r1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val (b, r3) = rb(r2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(a, b) to r3<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun &lt;A, B&gt; both(ra: Rand&lt;A&gt;, rb: Rand&lt;B&gt;): Rand&lt;Pair&lt;A, B&gt;&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;map2(ra, rb) { a, b -&gt; a to b }</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val rng = SimpleRNG(942)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intR: Rand&lt;Int&gt; = { rng -&gt; rng.nextInt() }<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleR: Rand&lt;Double&gt; = map(::nonNegativeInt) { i -&gt; i / (Int.MAX_VALUE.toDouble() + 1) }<br>&nbsp;&nbsp;&nbsp;&nbsp;val intDoubleR: Rand&lt;Pair&lt;Int, Double&gt;&gt; = both(intR, doubleR)<br>&nbsp;&nbsp;&nbsp;&nbsp;val (p, _) = intDoubleR(rng)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(p)<br>}</code></p>
      </div>
      <p>So we're taking the random numbers generated by <code>intR</code> (passed as <code>ra</code>)and <code>doubleR</code> (passed as <code>rb</code>) and creating a <code>Pair</code> with them (using the lambda <code>{ a, b -> a to b }</code>).</p>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
