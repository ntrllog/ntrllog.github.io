<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
                                      _
        /\     _             _   _   | |             __    __
       /  \   | |      /\   | \ | |  | |       /\   |  \  /  |
      /    \  | |     /  \  |  \| |  | |      /  \  | |\\//| |
     / ____ \ | |__  / __ \ | |\  |  | |___  / __ \ | | \/ | |
    /_/    \_\|____|/_/  \_\|_| \_|  |_____|/_/  \_\|_|    |_|
                          _   _
     _  _    _     _  _  | | | |   __     ____
    | |/ \  | |_  | |/_| | | | |  /  \   /    \
    | |   | |  _| |  /   | | | | | || | |  ||  |
    | |   | | |_  | |    | | | | | || | |  ||  |
    |_|   | |___| |_|    |_| |_|  \__/   \____/|
                                               |
                                          ____/
    -->
    <title>ntrllog | Functional Programming</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <link rel="shortcut icon" type="image/png" href="../pictures/favicon.ico"/>
    <link href="../css/content.css" rel="stylesheet">
  </head>
  <body>
    <div class="dropdown ln-fixed-right">
      <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">ToC</button>
      <ul class="dropdown-menu">
        <li><a class="dropdown-item" href="#purefuncs">Pure Functions</a></li>
        <li><a class="dropdown-item" href="#dataimmutability">Data Immutability</a></li>
        <li><a class="dropdown-item" href="#whyfp">Why Functional Programming?</a></li>
        <li><a class="dropdown-item" href="#tailrecursion">Tail Recursion</a></li>
        <li><a class="dropdown-item" href="#currying">Currying</a></li>
        <li><a class="dropdown-item" href="#polymorphic">Polymorphic Functions</a></li>
        <li><a class="dropdown-item" href="#generics">Generics</a></li>
        <li><a class="dropdown-item" href="#abstractdatatypes">Abstract Data Types</a></li>
        <li><a class="dropdown-item" href="#functionaldatastructures">Functional Data Structures</a></li>
      </ul>
    </div>
    <div class="container ln-line-height">
      <a href="projects.html"><i class="fas fa-long-arrow-alt-left fa-2x"></i></a>
      <h1>Functional Programming</h1>
      <hr>
      <p>Shortcut to this page: <a href="fp.html">ntrllog.netlify.app/fp</a></p>
      <p>Notes provided by Professor John Hurley</p>
      <p>(all code examples are done in Kotlin with expression bodies when possible)</p>
      <h2 id="purefuncs">Pure Functions</h2>
      <p>A pure function is a function that:</p>
      <ul>
        <li>always returns the same value for the same input</li>
        <li>has no side effects</li>
      </ul>
      <h3>Referential Transparency</h3>
      <p>Consider the function:</p>
      <div class="ln-center">
        <p><code>fun doubleIt(n: Int): Int = n * 2</code></p>
      </div>
      <p>and consider the input `n=3`. We can see that for `n=3`, the output will always be `6` no matter what.</p>
      <p>This can be thought of as referential transparency, meaning that calls to the same function with the same arguments will always return the same value.</p>
      <div class="ln-box">
        <p>Technically, referential transparency refers to the ability to replace an expression with its value while still maintaining the correctness of the code. For example, if, for some reason, we had <code>doubleIt(3)</code> in our code, we could replace it with <code>6</code> and the program would still work the same way.</p>
        <div class="ln-center">
          <p><code>val x = doubleIt(3) // this line can be rewritten as val x = 6</code></p>
        </div>
        <p>This replacement is possible only because the function will always return the same value for the same input. Which is why the definition of referential transparency can be thought of this way.</p>
        <p>(In a way, the definition of referential transparency is referentially transparent? ü§îüòè)</p>
      </div>
      <h4>That's Not Very Referentially Transparent of You</h4>
      <p>An example of a function that's not referentially transparent is this:</p>
      <div class="ln-flex-center">
        <p><code>val cost = 0.73<br>fun getCost(n: Int): Double = n * cost</code></p>
      </div>
      <p>If the value of <code>cost</code> is changed, then <code>getCost()</code> will return something different for the same input.</p>
      <h3>Side Effects</h3>
      <p>Side effects are changes that are caused by a function call, but the changes themselves occur outside of the function call. These changes usually are not necessary for calculating the return value of the function (assuming, in the spirit of functional programming, that the primary purpose of a function is to return something rather than do something). Some examples of side effects are:</p>
      <ul>
        <li>modifying a variable beyond the scope of the block where the change occurs</li>
        <li>modifying a data structure in place</li>
        <li>setting a field on an object</li>
        <li>throwing an exception or halting with an error</li>
        <li>printing to the console</li>
        <li>reading user input</li>
        <li>reading from or writing to a file</li>
        <li>drawing on the screen</li>
      </ul>
      <p>This is an example of a function that modifies a variable outside of its scope (and prints):</p>
      <div class="ln-flex-center">
        <p><code>var counter = 0<br>fun incrementCounter() {<br>&nbsp;&nbsp;&nbsp;&nbsp;++counter<br>&nbsp;&nbsp;&nbsp;&nbsp;println(counter)<br>}</code></p>
      </div>
      <h2 id="dataimmutability">Data Immutability</h2>
      <p>In functional programming, data are not allowed to be changed* once it is created. So something as simple (and seemingly essential) as a loop is not allowed. Consider this loop:</p>
      <div class="ln-flex-center">
        <p><code>for (num in numbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;squaredNums += listOf(num * num)<br>}</code></p>
      </div>
      <p><code>num</code> and <code>squaredNums</code> are being changed on every iteration of the loop, and data are not allowed to be changed!</p>
      <p>*Changed means reassigned to a different value.</p>
      <p>Instead of loops, recursion is used.</p>
      <p>In the context of lists, if we want a different list (e.g., one of the elements need to be changed or removed), then we need to create a new list instead of modifying the original list.</p>
      <div class="ln-flex-center">
        <p><code>val originalList = listOf(1, 2, 3, 4, 5)<br>val newList = originalList.slice(0..1) + originalList.slice(3..originalList.size-1) // newList = [1, 2, 4, 5]</code></p>
      </div>
      <h2 id="whyfp">Why Functional Programming?</h2>
      <p>With functional programming, there are no side effects; there are no mutable data; and there is referential transparency. All of these make functional programming great for concurrent programming because there is no shared state, data synchronization issues, race conditions, and deadlocks.</p>
      <p>The code is more modular since there is no shared state.</p>
      <p>Pure functions are less buggy than impure functions. Since they don't depend on external state, pure functions are more reliable once they are thoroughly tested. Pure functions also don't have side effects, so they don't create unpredictable problems.</p>
      <p>Referential transparency makes it possible to cache the result of a function call, so that the result can be used instead of calling the function again. (This is called memoization.)<p>
      <h2 id="tailrecursion">Tail Recursion</h2>
      <p>Whenever a function call is made, a stack is created for that function call. So for recursive functions, a stack is created for each recursive call.</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int = if (n &lt;= 1) n else n * factorial(n-1)</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/recursion.gif">
      </div>
      <p>If too many recursive calls are made, then too many stacks will be created, resulting in a stack overflow. Since we're pretty much limited to recursion in functional programming, we have to find a way to use recursion without running into a stack overflow.</p>
      <p>Well, we can avoid having too many stacks by getting rid of them once we don't need them anymore. Going back to the recursion animation above, notice that each stack after the main stack needs to allocate memory for an Int (the <code>n</code> in <code>n * factorial(n-1)</code>). This means that the recursive call is <em>not</em> the last thing that is performed in the stack (the multiplication is the last thing being performed). Because we need to store the <code>n</code> in each stack in order for the recursion to work, we cannot simply remove the stack after a recursive call. But it would be nice to be able to do so!</p>
      <p>So if we don't want to store anything in each stack, then that means we should push all the information we need to the next stack. Consider this modified factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3, 1)<br>}<br>fun factorial(n: Int, accumulator: Int): Int = if (n &lt;= 1) accumulator else factorial(n-1, n * accumulator)</code></p>
      </div>
      <p>This modification pushes the result of each multiplication forward (in the <code>accumulator</code>) so that it doesn't need to be stored.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.png">
        <p>(lol there's no animation here.)</p>
      </div>
      <p>Notice now that the recursive call <em>is</em> the last thing that is performed in the stack and that no memory needs to be allocated to store anything ‚Äî this is tail recursion! Capable compilers are able to take advantage of this and remove the previous stack on each recursive call ‚Äî after all, there's no important information being stored in the previous stack (this is tail-call elimination/optimization!)</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_1.gif">
      </div>
      <p>The fact that the stacks can be removed is nice, but this factorial function is a bit awkward. It's not intuitive to need two parameters to calculate the factorial of a number. In addition, if we accidentally put the wrong initial value for the accumulator, then the answer will be wrong.</p>
      <h3>Helper Function to the Rescue!</h3>
      <p>Consider this final version of the factorial function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val n = factorial(3)<br>}<br>fun factorial(n: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: Int, accumulator: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x &lt;= 1) accumulator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x-1, x * accumulator)<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(n, 1)<br>}</code></p>
      </div>
      <p>Here, we have a nested function (<code>helper()</code>) that is called recursively. The outer function (<code>factorial()</code>) is no longer called recursively; instead it kicks off the recursive process. This allows the factorial function to be clean while still getting the benefits of tail-call elimination.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/tail_recursion_2.gif">
      </div>
      <h3>A Systematic Approach to Making Functions Tail Recursive</h3>
      <p>There are three main ideas:</p>
      <ul>
        <li>there is an outer function that defines and calls an inner function, which is going to be the recursive one</li>
        <li>the inner function takes in an accumulator that starts with an initial value and builds up the result at each recursive step</li>
        <li>the base case returns the accumulator</li>
      </ul>
      <p>Let's look at string reversal as an example.</p>
      <p>There is an outer function:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {</code></p>
      </div>
      <p>That defines an inner function, which takes in an accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =</code></p>
      </div>
      <p>The base case returns the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc</code></p>
      </div>
      <p>The inner function is recursive and the accumulator builds up the result at each recursive step:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])</code></p>
      </div>
      <p>The outer function calls the inner function with an initial value for the accumulator:</p>
      <div class="ln-flex-center">
        <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(x: String, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x.length == 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(x.dropLast(1), acc + x[x.length-1])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s, "")<br>}</code></p>
      </div>
      <div class="ln-box">
        <h2>A Different Way To Recurse</h2>
        <p>Now, I don't know about you, but when I learned about recursion, there was always some argument that would get smaller with each recursive call. For example, in the example above, the string being passed to the recursive helper function is getting smaller by one character each time until it is empty. I never really realized that this is not the only way to do things recursively.</p>
        <p>If working with strings or lists, then instead of making the string or list smaller in each recursive call, we can just pass an increasing (or decreasing) index instead. ü§Ø</p>
        <div class="ln-flex-center">
          <p><code>fun myReverse(s: String): String {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int, acc: String): String =<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt; 0) acc<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else helper(n-1, acc + s[n])<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(s.length-1, "")<br>}</code></p>
        </div>
      </div>
      <h2 id="currying">Currying</h2>
      <p>Currying is taking a function with multiple arguments and breaking it up into mutiple functions, each with one argument.</p>
      <p>(I feel like a function that adds two numbers is a very contrived and overused example, but let's roll with it!) Suppose we have a function that adds two numbers:</p>
      <div class="ln-flex-center">
        <p><code>fun myAdd(x: Int, y: Int): Int = x + y</code></p>
      </div>
      <p>Now suppose we have a use case where we always want to add `5` to any number. Of course, we can simply just do <code>myAdd(x, 5)</code>, whenever we need to, but we can make the function calls simpler and clearer. The idea is to create a new function (let's call it <code>addFive()</code>) that takes in only one argument and adds `5` to it. Simpler and clearer.</p>
      <p>Time to curry the <code>myAdd()</code> function!</p>
      <div class="ln-flex-center">
        <p><code>fun addCurried(x: Int): (Int) -> Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(y: Int): Int = x + y<br>}<br>val add5 = addCurried(5)<br>val r = add5(10) // r = 15</code></p>
      </div>
      <p>We broke the <code>myAdd()</code> function into two smaller functions, each with one argument. The outer function takes in one of the arguments (<code>x</code>) and simply returns another function. That other function takes in the other argument (<code>y</code>) and does what the original <code>myAdd()</code> function would've done. Since the outer function returns a function, we can create new functions, like <code>add5()</code>.</p>
      <div class="ln-box">
        <h3>Closure</h3>
        <p>When we return from a function, everything in that function's scope gets destroyed. So it's interesting to note here that even when <code>addCurried()</code> returned, <code>add5()</code> still had access to the `5`, which was passed through <code>x</code>. Theoretically, <code>x</code> looks like it should've been inaccessible after <code>addCurried()</code> returned. But it isn't. A closure is a function that can access a variable that is defined outside of its scope, even after the outer function has returned.</p>
      </div>
      <p>Let's look at a more complicated, but more practical, example. Suppose we had our own filter function that filtered a list based on a custom function:</p>
      <div class="ln-flex-center">
        <p><code>fun myFilter(l: List&lt;Int&gt;, f: (Int) -> Boolean): List&lt;Int&gt; = l.filter(f)</code></p>
      </div>
      <p>Time to curry!</p>
      <div class="ln-flex-center">
        <p><code>fun filterCurried(f: (Int) -> Boolean): (List&lt;Int&gt;) -> List&lt;Int&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return fun(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter(f)<br>}<br>val isEven = { n: Int -> n % 2 == 0 }<br>val filterEven = filterCurried(isEven)<br>println(filterEven(listOf(1, 2, 3, 4, 5, 6)) // prints [2, 4, 6]</code></p>
      </div>
      <p>With this example, we can see a more useful reason to use currying. Imagine if we wanted to create <code>filterEven()</code> and <code>filterOdd()</code> but without currying.</p>
      <div class="ln-flex-center">
        <p><code>fun filterEven(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 0}<br>fun filterOdd(l: List&lt;Int&gt;): List&lt;Int&gt; = l.filter{it % 2 == 1}</code></p>
      </div>
      <p>Notice how they're almost exactly the same. It seems like wasted repetition to create two similarly-defined functions this way.</p>
      <h2 id="polymorphic">Polymorphic Functions</h2>
      <p>Consider this function that searches for a string in a list of strings:</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;String&gt;, key: String): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This is a monomorphic function because it operates only on one type of data, namely strings.</p>
      <p>What if we wanted to search for an integer in a list of integers?</p>
      <div class="ln-flex-center">
        <p><code>fun findFirst(l: List&lt;Int&gt;, key: Int): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>With the exception of the parameter types, the code is exactly the same. Of course, it seems like a waste to create two separate functions that do the exact same thing, just with different types.</p>
      <p>Polymorphic functions are functions that operate on any type that it is given.</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, key: A): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l.get(n) == key -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
      </div>
      <p>This function will work for strings, ints, doubles, anything really.</p>
      <div class="ln-box">
        <p>This type of polymorphism is called parametric polymorphism. Polymorphism in object-oriented programming is subtype polymorphism.</p>
      </div>
      <div class="ln-box">
        <h3>Predicate Functions</h3>
        <p>A predicate function is a pure function that returns either true or false. These are typically used as custom compare functions. For example, here is a predicate function (written as a lambda expression) that returns true if the input to the function contains the letter l:</p>
        <div class="ln-flex-center">
          <p><code>{ it.contains('l') }</code></p>
        </div>
        <p>So instead of being restricted to whatever condition is inside the when statement, we can pass our own compare function:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; findFirst(l: List&lt;A&gt;, f: (A) -&gt; Boolean): Int {<br>&nbsp;&nbsp;&nbsp;&nbsp;tailrec fun helper(n: Int): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n &gt;= l.size -&gt; -1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(l.get(n)) -&gt; n<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -&gt; helper(n+1)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;return helper(0)<br>}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>val i: Int = findFirst(l, { it.contains('l') })</code></p>
        </div>
      </div>
      <div class="ln-box">
        <p>Polymorphic functions are also called generic functions because the types are being abstracted.</p>
      </div>
      <div class="ln-box">
        <p>Quicksort is a sorting algorithm that starts with a pivot element, sorts the sublist that is "less than" the pivot element, sorts the sublist that is "greater than" the pivot element, and then combines them together to get a sorted list. Typically, the pivot is chosen randomly, but here we'll use the first element of the (sub)list(s) as the pivot.</p>
      </div>
      <p>Here's a pretty cool example of quicksort with generic types and a predicate function:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; quicksort(l: List&lt;A&gt;, f: (x: A, y: A) -&gt; Int): List&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;if (l.size &lt;= 1) l<br>&nbsp;&nbsp;&nbsp;&nbsp;else quicksort(l.drop(1).filter{ f(it, l.get(0)) &lt; 0 }, f) + l.get(0) + quicksort(l.drop(1).filter{ f(it, l.get(0)) &gt;= 0 }, f)</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val l1 = listOf(41, 89, -10, 54, 16, 543, 4)<br>&nbsp;&nbsp;&nbsp;&nbsp;val l2 = listOf("pizza", "taco", "cheeseburger", "french fries", "popcorn", "pie")<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l1, {x, y -&gt; if(x &lt; y) -1 else if(x == y) 0 else 1 }))<br>&nbsp;&nbsp;&nbsp;&nbsp;println(quicksort(l2, {x, y -&gt; if(x.length &lt; y.length) -1 else if( x.length == y.length) 0 else 1}))<br>}</code></p>
      </div>
      <p>As convenient as it looks, we don't always want polymorphic functions to accept any type. To show why, here's a simple example:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>Obviously, this only works with number-like types; so if we pass in a string, things will go wrong. To prevent this, we can restrict the types that can be used as type arguments:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Number&gt; oneHalf(value: A): Double = value.toDouble() / 2.0</code></p>
      </div>
      <p>This says that we can pass in any type for <code>A</code> as long as it is a Number type.</p>
      <p>A more practical example would be writing one compare function that works for multiple types, including custom classes:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A: Comparable&lt;A&gt;&gt; max(first: A, second: A): A = if (first.compareTo(second)) first else second</code></p>
      </div>
      <p>Here, we can pass in any type for <code>A</code> as long as it is Comparable.</p>
      <h2 id="generics">Generics</h2>
      <p>This naturally leads us to the concept of subtypes and supertypes. Suppose we have two types, `A` and `B`. Type `B` is a subtype of type `A` if you can use type `B` whenever type `A` is required. For example, Int is a subtype of Number; whenever the code expects a Number, we can pass an Int because technically, an Int is a Number.</p>
      <p>To be a little more precise, in order for a type to be a true subtype (i.e., in order to fit the actual definition of what it means to be a subtype), we must be able to replace the supertype with the subtype without causing any errors. This means that:</p>
      <ul>
        <li>A subtype must accept all argument types that the supertype can accept</li>
        <li>A subtype must not return a result type that the supertype won't return</li>
      </ul>
      <p>(When I say subtype and supertype here, I mean their functions.)</p>
      <p>(The following illustrations are adapted from <a href="https://typealias.com/guides/illustrated-guide-covariance-contravariance/" target="_blank">https://typealias.com/guides/illustrated-guide-covariance-contravariance/</a>. Most of the information in this section is also from that website.)</p>
      <p>For example, suppose we had a supertype with a function that takes in a shape and returns a color. It only accepts one square or one circle and returns only green or blue.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype.png">
      </div>
      <p>In order for a type to be a true subtype of the supertype, we have to be able to replace the supertype with the subtype without causing errors. The first rule says that "a subtype must accept all argument types that the supertype can accept". Let's see what happens if we don't follow that rule, i.e., the subtype <em>does not</em> accept all argument types that the supertype can accept.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_2.png">
      </div>
      <p>In this case, the subtype only accepts circles. The supertype accepted squares, and the function call in main was expecting the code to work with passing in a square. But when we replaced the supertype with the subtype, the code broke. So the subtype is not a true subtype.</p>
      <p>Let's look at the second rule: "a subtype must not return a result type that the supertype won't return". Again, we'll see what happens when we don't follow that rule, i.e., the subtype <em>does</em> return a type that the supertype doesn't return.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/subtype_3.png">
      </div>
      <p>This time, the subtype can also return orange. The supertype only returned green or blue, and the function call in main was expecting only green or blue, not orange! So the subtype is not a true subtype.</p>
      <p>Now, this doesn't mean that if we want to create true subtypes, we have to create carbon copies of the supertype. (If this was the case, there wouldn't really be a point in creating subtypes in the first place.) Subtypes can be a little bit more flexible and still be a true subtype.</p>
      <h3>Contravariance</h3>
      <p>Let's change the first rule from "a subtype must accept all argument types that the supertype can accept" to "a subtype must accept <em>at least</em> the argument types that the supertype can accept". Under this new rule, the subtype still technically accepts "all" the argument types that the supertype can accept, just a little bit more.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/contravariance.png">
      </div>
      <p>And this is fine. Remember that the definition of a true subtype is that we can replace the supertype without causing any errors. As far as main is concerned, it is still interacting with the supertype, so main will continue to pass only squares and circles.</p>
      <p>This is called contravariance because as the type gets more specific ("narrower"), the type of arguments that can be accepted get more general ("expands"). They go in opposite directions, hence the "contra".</p>
      <h3>Covariance</h3>
      <p>Let's change the second rule from "a subtype must not return a result type that the supertype won't return" to "a subtype must return <em>at most</em> the same result types that the supertype returns". Under this new rule, the subtype can choose to exclude something the supertype returns.</p>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/covariance.png">
      </div>
      <p>Again, this is fine because main is expecting either green or blue.</p>
      <p>This is called covariance because as the type gets more specific ("narrower"), the return types also get narrower. They go in the same direction, hence the "co".</p>
      <h3>New Rules!</h3>
      <p>So now the two rules for a subtype to be a true subtype are:</p>
      <ul>
        <li>A subtype must accept at least the argument types that the supertype can accept</li>
        <li>A subtype must return at most the same result types that the supertype returns</li>
      </ul>
      <h3>Variance</h3>
      <p>Variance is, at a very basic level, looking at if something is covariant or contravariant (or invariant, which we'll see right now).</p>
      <p>Since a String is a subtype of Any, is a MutableList of Strings a subtype of a MutableList of Anys?</p>
      <div class="ln-flex-center">
        <p><code>fun add42ToList(list: MutableList&lt;Any&gt;) {<br>&nbsp;&nbsp;&nbsp;&nbsp;list.add(42)<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val strings = mutableListOf("abc")<br>&nbsp;&nbsp;&nbsp;&nbsp;add42ToList(strings)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(strings.maxBy{ it.length })<br>}</code></p>
      </div>
      <p>This doesn't compile, but if it did, there would be a runtime error when calling the length method on an Int. Since we can't replace a MutableList of Anys with a MutableList of Strings, a MutableList of Strings is <em>not</em> a subtype of a MutableList of Anys.</p>
      <p>In fact, MutableList is invariant on the type parameter. That is, for any two different types `A` and `B`, <code>MutableList&lt;A&gt;</code> isn't a subtype or a supertype of <code>MutableList&lt;B&gt;</code>.</p>
      <h3>Generic Variance (Covariance)</h3>
      <p>Suppose we have a generic class <code>Group&lt;T&gt;</code>. If `A` is a subtype of `B` and <code>Group&lt;A&gt;</code> is a subtype of <code>Group&lt;B&gt;</code>, then the Group class is covariant. The subtyping is preserved, hence the "co".</p>
      <p>Now let's suppose that Group has two functions: insert() and fetch(). (Let's also suppose it's an interface instead of a class just so it compiles.)</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <p>Let's say we have two classes: an Animal class and a Dog class, where Dog is a subtype of Animal. If we want to make the Group class covariant, then <code>Group&lt;Dog&gt;</code> should be a subtype of <code>Group&lt;Animal&gt;</code>. Let's see what we have so far and see if it's possible.</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p>The way things are right now, <code>Group&lt;Dog&gt;</code> is not a subtype of <code>Group&lt;Animal&gt;</code> because <code>Group&lt;Dog&gt;</code> does not accept at least the same argument types that <code>Group&lt;Animal&gt;</code> accepts. For example, we could pass in a Cat to <code>Group&lt;Animal&gt;</code>'s insert() function, but we can't pass a Cat to <code>Group&lt;Dog&gt;</code>'s insert() function.</p>
      <p>Note that <code>Group&lt;Dog&gt;</code> already returns at most the same result types that <code>Group&lt;Animal&gt;</code> returns, so that rule is not being broken.</p>
      <h3>Kotlin Variance Annotation (out)</h3>
      <p>For now, let's remove the insert() function so that the first rule is not broken.</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}<br>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}</pre></p>
      </div>
      <p>Since both subtyping rules are not being broken anymore, <code>Group&lt;Dog&gt;</code> <em>is</em> a subtype of <code>Group&lt;Animal&gt;</code>. To tell Kotlin that we want to treat <code>Group&lt;Dog&gt;</code> as a subtype of <code>Group&lt;Animal&gt;</code>, we use the <code>out</code> annotation:</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;out T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>It's called "out" because the type is used only as an output.</p>
      </div>
      <div class="ln-box">
        <p>If we were to add the insert() function back, we would get a compile-time error: "Type parameter T is declared as 'out' but occurs in 'in' position in type T".</p>
        <div class="ln-flex-center">
          <p><code>interface Group&lt;out T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
        </div>
        <p>And as we just saw, this is because this violates the first subtype rule about accepting at least all of the supertype's arguments.</p>
        <p>(Note that adding the <code>out</code> modifier prevents us from creating any functions that take the type as a parameter, and therefore, breaking the above rule.)</p>
      </div>
      <h3>Generic Variance (Contravariance)</h3>
      <p>On the other hand, if `A` is a subtype of `B` and <code>Group&lt;B&gt;</code> is a subtype of <code>Group&lt;A&gt;</code>, then the Group class is contravariant. The subtyping is reversed, hence the "contra".</p>
      <p>If we want to make the Group class contravariant, then <code>Group&lt;Animal&gt;</code> should be a subtype of <code>Group&lt;Dog&gt;</code>. Let's see what we have so far and see if it's possible.</p>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Dog<br>}<br>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): Animal<br>}</pre></p>
      </div>
      <p>Well, <code>Group&lt;Animal&gt;</code> does accept at least the same argument types as <code>Group&lt;Dog&gt;</code> does, so that rule is fine. However, <code>Group&lt;Animal&gt;</code> can return more types than <code>Group&lt;Dog&gt;</code> can. So the second rule is being broken!</p>
      <h3>Kotlin Variance Annotation (in)</h3>
      <p>Similarly to before, let's remove the fetch() function so that the second subtyping rule is not broken.</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><pre>Group&lt;Dog&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Dog): Unit<br>}<br>Group&lt;Animal&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: Animal): Unit<br>}</pre></p>
      </div>
      <p>Now both subtyping rules are not being broken anymore, so <code>Group&lt;Animal&gt;</code> <em>is</em> a subtype of <code>Group&lt;Dog&gt;</code>. To tell Kotlin that we want to treat <code>Group&lt;Animal&gt;</code> as a subtype of <code>Group&lt;Dog&gt;</code>, we use the <code>in</code> annotation:</p>
      <div class="ln-flex-center">
        <p><code>interface Group&lt;in T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>It's called "in" because the type is used only as an input.</p>
      </div>
      <div class="ln-box">
        <p>If we were to add the fetch() function back, we would get a compile-time error: "Type parameter T is declared as 'in' but occurs in 'out' position in type T".</p>
        <div class="ln-flex-center">
          <p><code>interface Group&lt;in T&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun insert(item: T): Unit<br>&nbsp;&nbsp;&nbsp;&nbsp;fun fetch(): T<br>}</code></p>
        </div>
        <p>And as we just saw, this is because this violates the second subtype rule about returning at most all of the supertype's arguments.</p>
        <p>(Note that adding the <code>in</code> modifier prevents us from creating any functions that return the type, and therefore, breaking the above rule.)</p>
      </div>
      <div class="ln-box">
        <h3>Another Example With Squares</h3>
        <h4>Out</h4>
        <p>Suppose we had a Square class that can hold an item and return it:</p>
        <div class="ln-flex-center">
          <p><code>class Square&lt;out T&gt;(private val item: T) {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun getItem(): T = item<br>}</code></p>
        </div>
        <p>Let's look at what we are allowed to do with this Square. This first line is nothing special; we can assign a <code>Square&lt;Int&gt;</code> to a variable of type <code>Square&lt;Int&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>}</code></p>
        </div>
        <p>The next line is where it starts to get interesting. We can assign a <code>Square&lt;Int&gt;</code> to a variable of type <code>Square&lt;Number&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = intSquare<br>}</code></p>
        </div>
        <p>This is okay because the Square class is covariant (because of the <code>out</code> modifier); so <code>Square&lt;Int&gt;</code> is a subtype of <code>Square&lt;Number&gt;</code>.</p>
        <p><code>Square&lt;Number&gt;</code> can also call <code>getItem()</code> without any errors because the subtype (<code>Square&lt;Int&gt;</code>) does not return any values that the supertype (<code>Square&lt;Number&gt;</code>) doesn't return.</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = intSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;println(numSquare.getItem())<br>}</code></p>
        </div>
        <h4>In</h4>
        <p>Suppose we had a different Square class that can hold an item and compare it with another item:</p>
        <div class="ln-flex-center">
          <p><code>class Square&lt;in T&gt;(private val item: T) {<br>&nbsp;&nbsp;&nbsp;&nbsp;fun compareValues(otherItem: T): Boolean = item == otherItem<br>}</code></p>
        </div>
        <p>Similar to what we did above, we can assign a <code>Square&lt;Number&gt;</code> to a variable of type <code>Square&lt;Int&gt;</code> because <code>Square&lt;Number&gt;</code> is a subtype of <code>Square&lt;Int&gt;</code> (because of the <code>in</code> modifier):</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>}</code></p>
        </div>
        <p>For the same reason, we can also assign a <code>Square&lt;Number&gt;</code> to a variable of type <code>Square&lt;Double&gt;</code>:</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleSquare: Square&lt;Double&gt; = numSquare<br>}</code></p>
        </div>
        <p>And <code>Square&lt;Double&gt;</code> can call <code>compareValues()</code> because the subtype (<code>Square&lt;Number&gt;</code>) does accept at least the same argument types that the supertype (<code>Square&lt;Double&gt;</code>) does.</p>
        <div class="ln-flex-center">
          <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val numSquare: Square&lt;Number&gt; = Square(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;val intSquare: Square&lt;Int&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubleSquare: Square&lt;Double&gt; = numSquare<br>&nbsp;&nbsp;&nbsp;&nbsp;println(doubleSquare.compareValues(2.2))<br>}</code></p>
        </div>
      </div>
      <h2 id="abstractdatatypes">Abstract Data Types</h2>
      <p>An abstract data type is a basic (abstract) description of a data structure. It specifies the type of data stored, the operations supported, and the types of parameters of the operations. Most importantly, an ADT specifies what each operation does, but not how the operation does it.</p>
      <p>For example, a list is an abstract data type. We can say that the list holds Ints and that the operations we can perform on a list are to insert into and delete from the list. However, we are not specifying how the values of the list are stored, and we are not specifying how the insert and delete operations are implemented.</p>
      <p>On the other hand, a linked list is a data structure. Each element in the list is a node that contains a value and a pointer to the next node (we're specifying how the values of the list are stored). Insertion and deletion of elements are performed by following each node's next pointer to traverse the linked list until the desired node is reached (we're specifying how the operations are implemented).</p>
      <div class="ln-box">
        <p>The set of behaviors supported by the ADT is referred to as its public interface.</p>
      </div>
      <h2 id="functionaldatastructures">Functional Data Structures</h2>
      <p>Suppose we wanted to design an interface to compute expressions like `(1+2)+4`.</p>
      <div class="ln-flex-center">
        <p><code>interface Expr<br>class Num(val value: Int): Expr<br>class Sum(val left: Expr, val right: Expr): Expr</code></p>
      </div>
      <p>And to use this to represent `(1+2)+4`, it would look like this:</p>
      <div class="ln-flex-center">
        <p><code>Sum(Sum(Num(1), Num(2)), Num(4))</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/expr.png">
      </div>
      <p>To actually evaluate the result of the expression, we can write a function:</p>
      <div class="ln-flex-center">
        <p><code>fun eval(e: Expr): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when(e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Num -> e.value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Sum -> eval(e.right) + eval(e.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else -> throw IllegalArgumentException("Unknown expression")<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <p>And to call the function:</p>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;println(eval(Sum(Sum(Num(1), Num(2)), Num(4))))<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>We need to have the <code>else</code> part in the <code>when</code> expression because if new subclasses of <code>Expr</code> are created, the <code>when</code> expression needs to know how to handle those.</p>
        <p>However, we may not want other people to create new subclasses of <code>Expr</code> (and typing that <code>else</code> part can be a little annoying). In Kotlin, we can create a sealed class so that only the classes that are compiled with <code>Expr</code> can be subclasses. We do this by adding <code>sealed</code> in front of the class/interface.</p>
        <div class="ln-flex-center">
          <p><code>sealed interface Expr<br>class Num(val value: Int): Expr<br>class Sum(val left: Expr, val right: Expr): Expr<br><br>fun eval(e: Expr): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when(e) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Num -> e.value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is Sum -> eval(e.right) + eval(e.left)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
      </div>
      <p>Recall that in functional programming, data is not modified. This means that functional data structures must be immutable. So we can't use arrays, (imperative) linked lists, etc.</p>
      <p>Notice in the <code>Expr</code> example, when evaluating the result of the expression, we never changed any values. We sorta "passed it up the chain".</p>
      <p>In principle, if we want to perform insert or delete operations on functional data structures, we make a new copy based on the inputs but with the desired changes, leaving the inputs unmodified.</p>
      <h3>Singly Linked List</h3>
      <p>Linked lists are a common functional data structure because</p>
      <ul>
        <li>they're persistent</li>
        <li>prepending (producing a new list) is `O(1)`</li>
        <li>building an `n`-element list is `O(n)`</li>
      </ul>
      <div class="ln-box">
        <p>We can see why by comparing it to an array list, both the mutable and immutable versions.</p>
        <p>For the mutable array list:</p>
        <ul>
          <li>prepending is `O(n)` because everything has to be shifted over</li>
          <li>while appending is usually `O(1)`, it can be `O(n)` if the array list is full (we have to create a bigger array list to add the new element)
            <ul>
              <li>in the worst case, it's `O(n^2)` (think about starting with an array list of size `1` and appending)</li>
            </ul>
          </li>
        </ul>
        <p>For the immutable array list:</p>
        <ul>
          <li>a new array has to be created for each insert/delete operation, so building the list is `O(n^2)`</li>
        </ul>
      </div>
      <p>Here's how a functional singly linked list could be implemented:</p>
      <div class="ln-flex-center">
        <p><code>sealed class MyList&lt;out A&gt;<br>object MyNil: MyList&lt;Nothing&gt;()<br>data class MyCons&lt;out A&gt;(val head: A, val tail: MyList&lt;A&gt;): MyList&lt;A&gt;()</code></p>
      </div>
      <p>The object and the data class represent the two possibilities that a list can be. The <code>MyNil</code> object represents an empty list and <code>MyCons</code> represents a non-empty list. (Cons is short for "construct".) If there is only one item in the list, the tail is <code>MyNil</code>.</p>
      <div class="ln-box">
        <p>In Kotlin, <code>Nothing</code> is a subtype of every type. So by using the <code>out</code> annotation, <code>MyList&lt;Nothing&gt;</code> is a subtype of lists of any other types.</p>
      </div>
      <p>This is what it looks like to create a list:</p>
      <div class="ln-flex-center">
        <p><code>val l: MyList&lt;Int&gt; = MyCons(1, MyCons(2, MyCons(3, MyNil)))</code></p>
      </div>
      <div class="ln-center">
        <img class="img-fluid ln-image-small" src="../pictures/fp/cons.png">
      </div>
      <p>It is a little bit complicated to create lists this way. We can make it easier by creating a function similar to Kotlin's <code>listOf()</code> function.</p>
      <div class="ln-flex-center">
        <p><code>sealed class MyList&lt;out A&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;companion object {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun &lt;A&gt; of(vararg aa: A): MyList&lt;A&gt; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val tail = aa.sliceArray(1 until aa.size)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return if (aa.isEmpty()) MyNil else MyCons(aa[0], of(*tail))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val l = MyList.of(1, 4, 22, -30, 1)<br>}</code></p>
      </div>
      <div class="ln-box">
        <p>A companion object is a singleton object whose properties and functions are not tied to an instance of the class. This means that we can call a companion object's functions without having to create an instance of the class first. Basically, think of <code>static</code> in Java.</p>
        <p><code>vararg</code> specifies that the parameter will be an array*, where the number of elements can vary depending on how many arguments are passed. This makes the <code>of()</code> function a variadic function, meaning that it can accept zero or more arguments.</p>
        <p>The <code>*</code> in <code>MyCons(aa[0], of(*tail))</code> is the "spread operator", which passes the contents of an array as an argument to a function.</p>
        <p>*Wait a minute, didn't I say arrays weren't allowed in functional programming? In this case, the array isn't being changed (only consumed) so no data is being modified.</p>
      </div>
      <p>In addition (üòè), we can define functions to compute the sum (üòè) and product of all the elements in our list.</p>
      <div class="ln-flex-center">
        <p><code>fun sum(ints: MyList&lt;Int&gt;): Int =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (ints) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt; ints.head + sum(ints.tail)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun product(doubles: MyList&lt;Double&gt;): Double =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (doubles) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; 1.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (doubles.head == 0.0) 0.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else doubles.head * product(doubles.tail)<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-flex-center">
        <p><code>fun main() {<br>&nbsp;&nbsp;&nbsp;&nbsp;val ints = MyList.of(1, 4, 22, -30, 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(MyList.sum(ints))<br>&nbsp;&nbsp;&nbsp;&nbsp;val doubles = MyList.of(1.0, 4.0, 22.0, -30.0, 1.0)<br>&nbsp;&nbsp;&nbsp;&nbsp;println(MyList.product(doubles))<br>}</code></p>
      </div>
      <h3>Data Sharing</h3>
      <p>Now for the million-dollar question: since <code>MyList</code> is a functional data structure, how do we add and remove elements from <code>MyList</code>?</p>
      <p>Let's say we wanted to add an element to the front of a list. In this case, we return a new list with the element we want to add as the head and the existing list as the tail:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; prepend(l: MyList&lt;A&gt;, e: A): MyList&lt;A&gt; = MyCons(e, l)</code></p>
      </div>
      <p>If we want to remove an element from the front of a list, we return the list's tail:</p>
      <div class="ln-flex-center">
        <p><code>fun &lt;A&gt; premove(l: MyList&lt;A&gt;): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt; l.tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; MyNil<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
      </div>
      <div class="ln-box">
        <p>To insert and remove at any index:</p>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; insertAt(l: MyList&lt;A&gt;, index: Int, e: A): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (index == 0) MyCons(e, l)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else MyCons(l.head, insertAt(l.tail, index - 1, e))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; throw IndexOutOfBoundsException("Index out of bounds")<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <div class="ln-flex-center">
          <p><code>fun &lt;A&gt; removeAt(l: MyList&lt;A&gt;, index: Int): MyList&lt;A&gt; =<br>&nbsp;&nbsp;&nbsp;&nbsp;when (l) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyCons -&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (index == 0) l.tail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else MyCons(l.head, removeAt(l.tail, index - 1))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is MyNil -&gt; throw IndexOutOfBoundsException("Index out of bounds")<br>&nbsp;&nbsp;&nbsp;&nbsp;}</code></p>
        </div>
        <p>Basically, we recursively traverse the list until we reach the desired index.</p>
      </div>
      <p>A (perhaps) subtle thing to note here is that we're not actually creating new lists and copying over the values from the existing list to the new list; We're reusing the reference to the existing list. This is called data sharing.</p>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm" crossorigin="anonymous"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
  </body>
</html>
